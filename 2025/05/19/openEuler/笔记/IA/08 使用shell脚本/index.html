<!--
	作者：Sariay
	时间：2018-08-26
	描述：There may be a bug, but don't worry, Qiling(器灵) says that it can work normally! aha!
-->
<!DOCTYPE html>
<html class="html-loading">
		

<head>
	<meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <title>
    
      08 使用shell脚本 | XBCID&#39;s BLOG
    
  </title>
  <meta name="author" content="XBCID">
  <meta name="keywords" content="" />
  <meta name="description" content="" />
	<!-- favicon -->
  <link rel="shortcut icon" href="/img/favicon.ico">

  <!-- css -->
  
<link rel="stylesheet" href="/css/Annie.css">

  
  <!-- jquery -->
	
<script src="/plugin/jquery/jquery.min.js"></script>


<script>
    const CONFIG_BGIMAGE = {
      mode: 'normal',
      normalSrc: '/img/header-bg.jpg',
      randomYouMax: 110,
      randomYouSrc: 'https://sariay.github.io/Random-img/',
	  randomOtherSrc: 'https://api.berryapi.net/?service=App.Bing.Images&day=-0',
	  preloaderEnable: true
    }
	
    const CONFIG_LEACLOUD_COUNT = {
      enable: false,
	  appId: 'AU8...',
	  appKey: '4cU...',
	  serverURLs: 'http' || ' '
    }
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>
	<body>
		<!-- Preloader -->

	<div id="preloader">
		<div class="pre-container">
			
				<div class="spinner">
					<div class="double-bounce1"></div>
					<div class="double-bounce2"></div>
				</div>
						
		</div>
	</div>


<!-- header -->
<header class="fixbackground bg-pan-br">
	<div class="mask">
		<!-- motto -->
		<div class="h-body">	
			
				<div class="motto text-shadow-pop-left">
					<p class="content" id="motto-content">获取中...</p>
					<p>-<p>
					<p class="author" id="motto-author">Just a minute...</p>
				</div>
			
		</div>
		
		<!-- others: such as time... -->			
		<div class="h-footer">
			<a href="javascript:;" id="read-more" class="scroll-down">
				<span class="icon-anchor1 animation-scroll-down"></span>
			</a>
		</div>
	</div>
</header>

<div id="navigation-hide">
	<!-- Progress bar -->
	<div id="progress-bar"></div>

	<!-- Progress percent -->
	<div id="progress-percentage"><span>0.0%</span></div>

	<div class="toc-switch"><span class="switch-button">目录</span></div>

	<!-- Page title -->
	<p>
		
			「08 使用shell脚本」
		
	</p>

	
	

	<!-- Nav trigger for navigation-H-->
	<a class="nav-trigger"><span></span></a>
</div>

<!-- Navigation in div(id="navigation-H") -->
<nav class="nav-container" id="cd-nav">
	<div class="nav-header">
		<span class="logo"> 
			<img src="/img/logo.png">
		</span>
		<a href="javascript:;" class="nav-close"></a>
	</div>
	
	<div class="nav-body">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories" target="_blank">分类</a>
		</li>
		
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags" target="_blank">标签</a>
		</li>
		
	
		<li class="menu-about">
			<a href="/about" class="menu-item-about" target="_blank">关于</a>
		</li>
		
	
		<li class="menu-gallery">
			<a href="/gallery" class="menu-item-gallery" target="_blank">相册</a>
		</li>
		
	

	
</ul>
	</div>
	
	<div class="nav-footer">
		<ul id="global-social">
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-one"><span class="path1"></span><span class="path2"></span></span>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-zhihu"></span>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-github"></span>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-sina-weibo "></span>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-pinterest2"></span>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-instagram"></span>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-twitter"></span>
			</a>
		</li>
	
		<li>
			<a href="/atom.xml" target="_blank">
				<span class="icon-rss"></span>
			</a>
		</li>
			
</ul>

	</div>
</nav>
			
		<!--main-->
		<main>
			<!--
	时间：2018-11-17
	描述：
		插件名称：katelog.min.js
		插件作者：KELEN
		插件来源: https://github.com/KELEN/katelog
-->

	
		<div class="layout-toc">
			<div id="layout-toc">
				<div class="k-catelog-list" id="catelog-list" data-title="文章目录"></div>
			</div>
		</div>

		
<script src="/plugin/toc/katelog.min.js"></script>


		
	 

<div class="layout-post">
	<div id="layout-post">
		<div class="article-title">
			
	<a href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IA/08%20%E4%BD%BF%E7%94%A8shell%E8%84%9A%E6%9C%AC/" itemprop="url">
		08 使用shell脚本
	</a>

		</div>

		<div class="article-meta">
			<span>
				<i class="icon-calendar1"></i>
				
				




	更新于

	<a href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IA/08%20%E4%BD%BF%E7%94%A8shell%E8%84%9A%E6%9C%AC/" itemprop="url">
		<time datetime="2025-05-18T19:46:45.683Z" itemprop="dateUpdated">
	  		2025-05-19
	  </time>
	</a> 



			</span>
			<span>
				
	<i class="icon-price-tags"></i>
	
		<a href="/tags/Linux/" class=" ">
			Linux
		</a>
	
		<a href="/tags/openEuler/" class=" ">
			openEuler
		</a>
	
		<a href="/tags/Huawei/" class=" ">
			Huawei
		</a>
	
		<a href="/tags/HCIA/" class=" ">
			HCIA
		</a>
	
		
			</span>
			
			



		</div>

		<div class="article-content" id="article-content">
			<ul>
<li>本课程基于 openEuler</li>
<li>介绍关于 Shell 的基础知识</li>
<li>结合实际案例展示 Shell 脚本编写的最佳实践</li>
</ul>
<p>学完本课程后，您应该能：</p>
<ul>
<li>熟悉 Shell 基础知识</li>
<li>掌握 Shell 编程基础</li>
<li>能够编写常用的 Shell 脚本</li>
</ul>
<p><img src="/assets/08%20%E4%BD%BF%E7%94%A8shell%E8%84%9A%E6%9C%AC/2025020719-4609642.png"></p>
<hr>
<h2 id="0x01-Shell基础介绍"><a href="#0x01-Shell基础介绍" class="headerlink" title="0x01 Shell基础介绍"></a>0x01 Shell基础介绍</h2><h3 id="1-1-openEuler构成Shell简介"><a href="#1-1-openEuler构成Shell简介" class="headerlink" title="1.1 openEuler构成Shell简介"></a>1.1 openEuler构成Shell简介</h3><ul>
<li>了解 Shell 在 openEuler 中的位置</li>
<li>掌握 Shell 脚本的基本操作</li>
</ul>
<hr>
<h4 id="1-1-1-Shell-概述"><a href="#1-1-1-Shell-概述" class="headerlink" title="1.1.1 Shell 概述"></a>1.1.1 Shell 概述</h4><ul>
<li>Shell 是系统的用户界面，提供了用户与内核进行交互操作的一种接口</li>
<li>Shell 将用户输入的命令并且把它们送到内核去执行，然后返回执行结果</li>
<li>Shell 是可编程的，它允许用户编写由 Shell 命令组成的程序</li>
<li><img src="/assets/08%20%E4%BD%BF%E7%94%A8shell%E8%84%9A%E6%9C%AC/2025020713-0211287.png"></li>
</ul>
<h4 id="1-1-2-Shell发展史"><a href="#1-1-2-Shell发展史" class="headerlink" title="1.1.2 Shell发展史"></a>1.1.2 Shell发展史</h4><p>1971 : Bell Labs 的 Ken Thompson 为 UNIX 开发了第一个 Shell: V6 Shell 是一个在内核之外执行的独立的用户程序<br>1977 ：Steven Bourne 在 AT&amp;T Bell Labs 为 V7 UNIX 创建 Bourne shell<br>1978 ：Bill Joy 在伯克利分校攻读研究生期间为 BSD UNIX 系统开发的 csh<br>1983 ： Ken Greer 在卡内基-梅隆大学开发了 tcsh，将 C Shell 引入了 Tenex 系统中的一些功能，如命令行编辑功能和文件名和命令自动补全功能<br>1983 ：David Korn 在 AT&amp;T Bell Labs 创建 korn shell，它功能更强大，提供关联数组表达式运算<br>1989 ：Bourne-Again Shell（或 Bash）是一个开源 GNU 项目，旨在取代 Bourne shell；Bash 由 Brian Fox 开发，已成为世上最流行的 Shell，它兼容 sh、csh、ksh，是 Linux 系统的默认 Shell</p>
<p><img src="/assets/08%20%E4%BD%BF%E7%94%A8shell%E8%84%9A%E6%9C%AC/2025020713-0643357.png"></p>
<p>在 Linux 中，有多种 Shell 程序可供选择，比如 dash、csh、zsh 等，默认的 Shell 可以在 &#x2F;bin&#x2F;sh 查看，在&#x2F;etc&#x2F;passwd 中修改。</p>
<h4 id="1-1-4-查看Shell"><a href="#1-1-4-查看Shell" class="headerlink" title="1.1.4 查看Shell"></a>1.1.4 查看Shell</h4><p>登陆 openEuler，查看系统默认安装的 Shell</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure>

<p>查看当前登陆用户默认 Shell</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure>

<p>查看当前的 Shell</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $0</span><br></pre></td></tr></table></figure>


<h3 id="1-2-Shell脚本（定义、作用、格式、权限及执行）"><a href="#1-2-Shell脚本（定义、作用、格式、权限及执行）" class="headerlink" title="1.2 Shell脚本（定义、作用、格式、权限及执行）"></a>1.2 Shell脚本（定义、作用、格式、权限及执行）</h3><h4 id="1-2-1-Shell脚本基础知识"><a href="#1-2-1-Shell脚本基础知识" class="headerlink" title="1.2.1 Shell脚本基础知识"></a>1.2.1 Shell脚本基础知识</h4><ul>
<li>在Unix&#x2F;Linux 里，一个程序&#x2F;命令只做好一件事</li>
<li>复杂的问题可以通过多个命令的组合来解决</li>
<li>形式最简单的 Shell 脚本就是一系列命令构成的可执行文件，并可以被其他脚本复用</li>
</ul>
<blockquote>
<p>编写风格良好易读的 Shell 脚本<br>可以提高日常任务的自动化程度和准确性</p>
</blockquote>
<h4 id="1-2-2-Shell脚本的约束"><a href="#1-2-2-Shell脚本的约束" class="headerlink" title="1.2.2 Shell脚本的约束"></a>1.2.2 Shell脚本的约束</h4><ul>
<li>没有“银弹<ul>
<li>Shell 脚本可以完成很多任务，但不适用于所有情况</li>
<li>对于可以通过调用其他命令行实用工具来完成的任务，Shell 脚本是一种不错的选择</li>
<li>Shell 脚本可以作为一种“胶水”语言，整合其他编程语言</li>
<li>银弹：没有一个工具可以解决所有问题</li>
</ul>
</li>
</ul>
<blockquote>
<p>当解决某个问题时，<br>Shell 脚本实现起来复杂度高，效率低，<br>此时就可以考虑使用其他编程语言。</p>
</blockquote>
<h4 id="1-2-3-Shell脚本开发环境"><a href="#1-2-3-Shell脚本开发环境" class="headerlink" title="1.2.3 Shell脚本开发环境"></a>1.2.3 Shell脚本开发环境</h4><ul>
<li>可以在任意文本编辑器中打开新文件来创建 Shell 脚本</li>
<li>高级编辑器如 Vim 和 Emacs，在识别文件的后缀为 .sh 后，可以提供语法高亮、检查、补全等功能<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@openEuler ~]# vim demo.sh #新建一个脚本文件，并写入如下内容：</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;Hello World“</span><br><span class="line">[root@openEuler ~]# sh demo.sh</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-2-4-Shell脚本指定解释器"><a href="#1-2-4-Shell脚本指定解释器" class="headerlink" title="1.2.4 Shell脚本指定解释器"></a>1.2.4 Shell脚本指定解释器</h4><ul>
<li>Shell脚本只是静态的代码，若要输出结果，还需要解释器的参与</li>
<li>一般在脚本的第一行，指定执行此脚本的解释器</li>
<li>如果不指定解释器，脚本也能在默认的解释器中正常运行，但出于规范和安全的考虑，建议指定如下：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/csh</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-2-5-执行Shell脚本"><a href="#1-2-5-执行Shell脚本" class="headerlink" title="1.2.5 执行Shell脚本"></a>1.2.5 执行Shell脚本</h4><ul>
<li><p>对于脚本文件，我们有两种执行方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh scipt_name.sh</span><br><span class="line">./script_name.sh</span><br></pre></td></tr></table></figure></li>
<li><p>Linux中一切皆文件，脚本&#x2F;命令&#x2F;程序都是一个文件，文件作为一个对象，具有权限的属性</p>
</li>
<li><p>在执行别人发送或从网上下载的脚本时可能会遇到权限问题，赋予执行权限可解决</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x script_name.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果某个 Shell 脚本可执行，则可以通过在命令行中输入其名称调用</p>
<ul>
<li>如果某个 Shell 脚本可执行，则可以通过在命令行中输入其名称调用<ul>
<li>查看 <code>$PATH</code> 变量</li>
<li>修改 <code>$PATH</code> 变量</li>
<li>查找某个命令&#x2F;脚本的路径</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@openEuler ~]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class="line">[root@openEuler ~]# PATH=$PATH:/New/path</span><br><span class="line">[root@openEuler ~]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/New/path</span><br></pre></td></tr></table></figure>
<ul>
<li>永久修改<code>$PATH</code>需要在<code>.bashrc</code>或<code>.bash_profile</code>中添加<code>export PATH=&quot;$PATH:/new/path&quot;</code></li>
<li>关于变量的细节，后续章节还会提到</li>
</ul>
<h4 id="1-2-6-后台执行Shell脚本"><a href="#1-2-6-后台执行Shell脚本" class="headerlink" title="1.2.6 后台执行Shell脚本"></a>1.2.6 后台执行Shell脚本</h4><ul>
<li>有时候一些脚本执行时间较长，命令行界面会被占用，因此可以采取后台运行脚本<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./my_script.sh &amp;</span><br></pre></td></tr></table></figure></li>
<li>这种方法在退出Shell后，脚本进程会随之终止，为了保证脚本一直运行，可以采用：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./my_script.sh &amp;</span><br></pre></td></tr></table></figure>
脚本的标准输出和标准错误会重定向到nohup.out文件里</li>
<li>使用jobs命令可以查看后台中运行着的进程</li>
</ul>
<h2 id="0x02-Shell编程基础"><a href="#0x02-Shell编程基础" class="headerlink" title="0x02 Shell编程基础"></a>0x02 Shell编程基础</h2><ul>
<li>理解 Linux 中文本流的输入、输出以及重定向</li>
<li>掌握 Linux 中管道的用法</li>
<li>掌握 Shell 中的变量、运算符</li>
<li>掌握 Shell 中的逻辑判断、选择结构、循环结构</li>
</ul>
<hr>
<h3 id="2-1-输入输出、管道"><a href="#2-1-输入输出、管道" class="headerlink" title="2.1 输入输出、管道"></a>2.1 输入输出、管道</h3><h4 id="2-1-1-Linux中的文本流"><a href="#2-1-1-Linux中的文本流" class="headerlink" title="2.1.1 Linux中的文本流"></a>2.1.1 Linux中的文本流</h4><ul>
<li>文本流存在于Linux的每一个进程中</li>
<li>Linux的每个进程启动时，会打开三个文本流的端口：标准输入、标准输出、标准错误</li>
<li>这三个端口对应着一个程序的输入、输出和异常的抛出<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@openEuler ~]# date</span><br><span class="line">Wed Jul 29 10:39:17 CST 2020</span><br><span class="line">[root@openEuler ~]# datee</span><br><span class="line">bash: datee: command not found</span><br></pre></td></tr></table></figure>
<strong>例如：</strong><br>在 bash 中输入一串字符后，bash 进程中的标准输入端口捕获命令行中的输入，<br>进行处理后从标准输出端口中传出，回显在屏幕上，<br>如果处理过程中发生异常，则会通过标准错误端口，将异常回显在屏幕上。</li>
</ul>
<h4 id="2-1-2-输出重定向"><a href="#2-1-2-输出重定向" class="headerlink" title="2.1.2 输出重定向"></a>2.1.2 输出重定向</h4><ul>
<li>某些情况下，我们需要保存程序的输出，此时就可以通过重定向，将程序的输出保存到文件中</li>
</ul>
<ol>
<li>将标准输出定向到文件中：<ul>
<li><code>ls &gt; dir_log</code></li>
<li>使用这种方式会将程序的标准输出覆盖文件内容</li>
</ul>
</li>
<li>将标准输出追加到文件中：<ul>
<li><code>ls &gt;&gt; dir_log</code></li>
<li>使用这种方式会将标准输出追加至文件的末尾</li>
</ul>
</li>
<li>执行完命令后，可以通过<code>cat dir_log</code>查看保存的文件内容</li>
</ol>
<h4 id="2-1-3-输入重定向"><a href="#2-1-3-输入重定向" class="headerlink" title="2.1.3 输入重定向"></a>2.1.3 输入重定向</h4><ul>
<li>与输出重定向类似，输入重定向是把程序的标准输入进行重新定向</li>
<li>输入重定向：<ul>
<li>格式：<code>command &lt; inputfile</code></li>
<li>将右边的文件作为标准输入，然后传入左边的命令</li>
<li>例：<code>wc -l &lt; /dev/null</code></li>
</ul>
</li>
<li>内联输入重定向：<ul>
<li>格式：<code>command &lt;&lt; maker</code></li>
<li>输出重定向需要文件，而内联输入重定向可以使用即时输入的文本作为标准输入，传入左边的命令</li>
<li>右边的字符“maker”作为标志，表示标准输入的开始和结束，自身不包含在标准输入里。</li>
<li>右图例中以“EOF”作为标志</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@openEuler ~]# less &lt;&lt; EOF</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">item 1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">item 2</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">item 3</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">EOF</span></span><br><span class="line">item 1</span><br><span class="line">item 2</span><br><span class="line">item 3</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>command &lt;&lt; maker &gt;file</code></li>
</ul>
<h4 id="2-1-4-管道"><a href="#2-1-4-管道" class="headerlink" title="2.1.4 管道"></a>2.1.4 管道</h4><ul>
<li>有时需要将一个命令的输出连到另一个命令的输入，如果用重定向实现会较复杂</li>
<li>管道( | )就像现实中的水管一样，可以连接两个命令的输入和输出，甚至是串联多个命令</li>
<li>格式：<code>command1 | command2 | command3</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@openEuler ~] ls /bin/ | grep python | less</span><br></pre></td></tr></table></figure></li>
<li>管道实际上是进程间通信（IPC）的一种方式</li>
</ul>
<h3 id="2-2-字符、变量、运算"><a href="#2-2-字符、变量、运算" class="headerlink" title="2.2 字符、变量、运算"></a>2.2 字符、变量、运算</h3><h4 id="2-2-1-Shell中的字符"><a href="#2-2-1-Shell中的字符" class="headerlink" title="2.2.1 Shell中的字符"></a>2.2.1 Shell中的字符</h4><p>和其他编程语言一样，Shell 也有一些保留字（特殊字符），在编写脚本时需要注意<br><img src="/assets/08%20%E4%BD%BF%E7%94%A8shell%E8%84%9A%E6%9C%AC/2025020719-5649485.png"></p>
<ul>
<li>注释符号(Hashmark<code>[Comments]</code>)<ul>
<li>在shell文件的行首，作为<a href="%E6%B3%A8%E9%87%8A/shebang.md">shebang</a>标记，<code>#!/bin/bash</code>;</li>
<li>其他地方作为注释作用，在一行中，#后面的内容并不会被执行，除非；</li>
<li>但是用单&#x2F;双引号包围时，<code>#</code>作为<code>#</code>号字符本身，不具有注释作用。</li>
</ul>
</li>
<li>单引号（full quoting <code>[single quote]</code>)<ul>
<li>单引号括住的内容，被视为单一字符串，引号内的禁止变量扩展，所有字符均作为字符本身处理（除单引号本身之外），单引号必须成对出现。</li>
</ul>
</li>
<li>反斜线，反斜杆(escape<code>[backslash]</code>)<ul>
<li>放在特殊符号之前，转义特殊符号的作用，仅表示特殊符号本身，这在字符串中常用；</li>
<li>放在一行指令的最末端，表示紧接着的回车无效（其实也就是转义了Enter），后继新行的输入仍然作为当前指令的一部分。</li>
</ul>
</li>
<li>斜线，斜杆（<code>Filename path separator [forward slash]</code>）<ul>
<li>作为路径的分隔符，路径中仅有一个斜杆表示根目录，以斜杆开头的路径表示从根目录开始的路径；</li>
<li>在作为运算符的时候，表示除法符号。如：a&#x3D;4&#x2F;2</li>
</ul>
</li>
<li>感叹号（<code>reverse (or negate) [bang],[exclamation mark]</code>)<ul>
<li>取反一个测试结果或退出状态</li>
<li>表示反逻辑，比如后面的!&#x3D;,这个是表示不等于；</li>
<li>表示取反，如：<code>ls a[!0-9]</code>#表示a后面不是紧接一个数字的文件；&#96;</li>
</ul>
</li>
</ul>
<h4 id="2-2-2-变量"><a href="#2-2-2-变量" class="headerlink" title="2.2.2 变量"></a>2.2.2 变量</h4><ul>
<li>任何语言都有变量这个要素</li>
<li>Shell与其他强类型的编程语言如：C，Java和C++等有很大不同，Shell中的变量是无类型的</li>
<li>通过一个变量，我们可以引用一块内存区域的值，变量名就是这块内存区域上贴的一个标签</li>
<li>变量赋值：<code>variable=value</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@openEuler ~]# a=&#x27;Hello World&#x27;</span><br><span class="line">[root@openEuler ~]# echo a</span><br><span class="line">a</span><br><span class="line">[root@openEuler ~]# echo $a</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-2-2-1-变量的类型"><a href="#2-2-2-1-变量的类型" class="headerlink" title="2.2.2.1 变量的类型"></a>2.2.2.1 变量的类型</h5><ul>
<li><p>在 Linux Shell 中，变量主要有两大类：</p>
<ul>
<li>环境变量</li>
<li>用户定义变量</li>
</ul>
</li>
<li><p>每种类型的变量依据作用域不同，又分为全局变量和局部变量</p>
<ul>
<li>全局变量作用在整个Shell会话及其子Shell</li>
<li>局部变量作用在定义她们的进程及其子进程内</li>
</ul>
</li>
<li><p>查看变量</p>
<ul>
<li>使用<code>printenv</code>查看全局变量</li>
<li>使用<code>set</code>查看某个特定进程中的所有变量，包括局部变量、全局变量以及用户定义变量</li>
</ul>
</li>
<li><p>修改变量</p>
<ul>
<li>在.bash_profile或.bashrc中添加export语句，永久修改变量</li>
</ul>
</li>
<li><p>对比<code>printenv</code>与<code>set</code>的区别：<code>dif -yw &lt;(printenv)&lt;(set)</code></p>
</li>
<li><p>命令<code>set</code>是<code>Shell</code>中的一个内建命令，它能够显示当前<code>Shell</code>中的变量，以及用户自定义的变量，不管该变量有没有<code>export</code>。<code>set</code>命令允许你更改<code>Shell</code>选项的值并设置位置参数，或者显示<code>Shell</code>变量的名称和值。如果未提供任何选项或参数，则会设置显示所有<code>Shell</code>变量和函数的名称和值（按照当前语言环境排序），并且输出的格式可以重新用作设置或重置当前设置变量的输入</p>
</li>
<li><p><code>printenv</code>和<code>env</code>在环境变量打印方面是类似的。但是在功能上，<code>env</code>主要用于设置环境变量并运行指定的命令命令，而<code>printenv</code>是为了打印环境变量。</p>
</li>
<li><p>set则是一个Shell的内建命令，与Shell有关，用于设置Shell的属性。</p>
</li>
</ul>
<h5 id="2-2-2-2-使用变量-单、双引号"><a href="#2-2-2-2-使用变量-单、双引号" class="headerlink" title="2.2.2.2 使用变量(单、双引号)"></a>2.2.2.2 使用变量(单、双引号)</h5><ul>
<li>Shell变量命名规则：<ul>
<li>变量名由数字、字母、下划线组成</li>
<li>必须以字母或者下划线开头、</li>
<li>不能使用Shell里的关键字</li>
</ul>
</li>
<li>定义变量的格式：<ul>
<li>variable&#x3D;value</li>
<li>variable&#x3D;’value’</li>
<li>variable&#x3D;”value”</li>
</ul>
</li>
<li><strong>赋值号的周围不能有空格</strong></li>
<li>如果有必要，也可以使用 declare 关键字显式定义变量的类型</li>
<li>查询关键字：<code>help | grep &lt;keywords&gt;</code></li>
<li>如果<code>value</code>包含了空白符，则需要用引号包裹起来<ul>
<li>单引号包裹的内容，shell不展开命令、变量，即原样输出</li>
<li><strong>双引号反之，会展开其中包裹的命令和变量</strong></li>
</ul>
</li>
</ul>
<h5 id="2-2-2-3-扩展变量"><a href="#2-2-2-3-扩展变量" class="headerlink" title="2.2.2.3 扩展变量"></a>2.2.2.3 扩展变量</h5><ul>
<li>在以下示例中，如果不使用花括号，Bash会将<code>$FIRST_$LAST</code>解释为变量<code>$FIRST_</code>后跟变量<code>$LAST</code>，而不是由_字符分隔的变量<code>$FIRST</code>和<code>$LAST</code></li>
<li>因此，在此情况下，必须使用花括号引用的形式才能使变量扩展正确运行<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@openEuler ~]# FIRST_=Jane</span><br><span class="line">[root@openEuler ~]# FIRST=john</span><br><span class="line">[root@openEuler ~]# LAST=Doe</span><br><span class="line">[root@openEuler ~]# echo $FIRST_$LAST</span><br><span class="line">Doe</span><br><span class="line">[root@openEuler ~]# echo $&#123;FIRST&#125;_$LAST</span><br><span class="line">john_Doe</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-2-2-4-变量的赋值与输出"><a href="#2-2-2-4-变量的赋值与输出" class="headerlink" title="2.2.2.4 变量的赋值与输出"></a>2.2.2.4 变量的赋值与输出</h5><ul>
<li>定义并赋值如下变量，个人姓名name,日期date</li>
<li>输出姓名及日期变量</li>
<li>读取输入并输出</li>
<li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name=Euler</span><br><span class="line">time=&#x27;20250208&#x27;</span><br><span class="line">echo &quot;My name is $name,today is $time&quot;</span><br><span class="line">read name</span><br><span class="line">echo &quot;Hello,$name,welcome&quot;</span><br></pre></td></tr></table></figure></li>
<li>read 命令，等待用户输入，随后将输入的内容赋给变量</li>
</ul>
<h4 id="2-2-3-Shell的算术扩展"><a href="#2-2-3-Shell的算术扩展" class="headerlink" title="2.2.3 Shell的算术扩展"></a>2.2.3 Shell的算术扩展</h4><ul>
<li>算术扩展可用于执行简单的整数算术运算</li>
<li>语法：<code>$[表达式]</code></li>
<li>例：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@openEuler ~]# echo $[1+1]</span><br><span class="line">2</span><br><span class="line">[root@openEuler ~]# echo $[2*2]</span><br><span class="line">4</span><br><span class="line">[root@openEuler ~]# COUNT=1; echo $[$[$COUNT+1]*2]</span><br><span class="line">4</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-2-3-1-在Shell中计算时间"><a href="#2-2-3-1-在Shell中计算时间" class="headerlink" title="2.2.3.1 在Shell中计算时间"></a>2.2.3.1 在Shell中计算时间</h5><ul>
<li>定义24小时，60分钟，60秒变量</li>
<li>定义每天秒数变量并赋值</li>
<li>输出变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@openEuler ~]# SEC_PER_MIN=60</span><br><span class="line">[root@openEuler ~]# MIN_PER_HR=60</span><br><span class="line">[root@openEuler ~]# HR_PER_DAY=24</span><br><span class="line">[root@openEuler ~]# SEC_PER_DAY=$[ $SEC_PER_MIN * $MIN_PER_HR * $HR_PER_DAY ]</span><br><span class="line">[root@openEuler ~]# echo &quot;There are $SEC_PER_DAY seconds in a day&quot;</span><br><span class="line">There are 86400 seconds in a day</span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-2-算术运算常用表达式"><a href="#2-2-3-2-算术运算常用表达式" class="headerlink" title="2.2.3.2 算术运算常用表达式"></a>2.2.3.2 算术运算常用表达式</h5><p><img src="/assets/08%20%E4%BD%BF%E7%94%A8shell%E8%84%9A%E6%9C%AC/2025020813-0716787.png"></p>
<h6 id="2-2-3-2-1-算术运算的优先级"><a href="#2-2-3-2-1-算术运算的优先级" class="headerlink" title="2.2.3.2.1 算术运算的优先级"></a>2.2.3.2.1 算术运算的优先级</h6><p>优先级由高到低如下：<br><img src="/assets/08%20%E4%BD%BF%E7%94%A8shell%E8%84%9A%E6%9C%AC/2025020814-1712460.png"></p>
<h6 id="2-2-3-2-2-变量递增的前置后置区别"><a href="#2-2-3-2-2-变量递增的前置后置区别" class="headerlink" title="2.2.3.2.2 变量递增的前置后置区别"></a>2.2.3.2.2 变量递增的前置后置区别</h6><p><code>echo $[++i]</code>和<code>echo $[i++]</code>输出是否一样？<br>在触发边界条件时有哪些场景需要注意？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@openEuler ~]# i=3</span><br><span class="line">[root@openEuler ~]# echo $[i]</span><br><span class="line">3</span><br><span class="line">[root@openEuler ~]# echo $[++i]</span><br><span class="line">4</span><br><span class="line">[root@openEuler ~]# echo $[i++]</span><br><span class="line">4</span><br><span class="line">[root@openEuler ~]# echo $i</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<ul>
<li>i++ 要开辟一个变量来保存 i 的值 并返回，然后让 i 这个变量 的值 +1 。而 ++i 直接把 1 加到 i 这个 变量的空间中去，并返回这个空间 中的值， 没有开辟任何临时空间，性能更高</li>
<li>图中返回的变量是 i，所以有这样的差异</li>
</ul>
<h3 id="2-3-语句（条件，循环）"><a href="#2-3-语句（条件，循环）" class="headerlink" title="2.3 语句（条件，循环）"></a>2.3 语句（条件，循环）</h3><h4 id="2-3-1-Shell-中的结构化命令"><a href="#2-3-1-Shell-中的结构化命令" class="headerlink" title="2.3.1 Shell 中的结构化命令"></a>2.3.1 Shell 中的结构化命令</h4><ul>
<li>在 Shell 脚本里除了顺序执行，还需要一些额外的逻辑控制流程</li>
<li>和其他编程语言类似， Shell 中的结构化命令主要包括条件、循环两类</li>
</ul>
<h4 id="2-3-2-条件语句"><a href="#2-3-2-条件语句" class="headerlink" title="2.3.2 条件语句"></a>2.3.2 条件语句</h4><ul>
<li><code>if-then</code>语句</li>
<li>语法：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if command</span><br><span class="line">	then</span><br><span class="line">		commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
<li>Bash Shell 会先执行 if 后面的语句，如果其退出状态码为 0，则会继续执行 then 部分的命令，否则会执行脚本中的下一个命令</li>
<li>Shell 中的 if 和其他 if 判断的条件不太一样，需注意</li>
</ul>
<h5 id="2-3-2-1-多分支判断语句"><a href="#2-3-2-1-多分支判断语句" class="headerlink" title="2.3.2.1 多分支判断语句"></a>2.3.2.1 多分支判断语句</h5><ul>
<li>在涉及多条件判断时，可能会使用较为繁琐的 if-then-else 语句，通过 elif 语句频繁检测同一个变量的值，此时更适合使用 case 语句</li>
<li>语法：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case variable in</span><br><span class="line">pattern1 | pattern2) commands1;;</span><br><span class="line">pattern3) commands2;;</span><br><span class="line">*) default commands;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li>
<li>case 语句会将指定的变量与不同的模式比较，若匹配，则执行对应的命令</li>
<li>用 | 可以分割出多个模式</li>
<li>用 * 代表所有与已知模式不匹配的值</li>
</ul>
<h4 id="2-3-3-循环语句"><a href="#2-3-3-循环语句" class="headerlink" title="2.3.3 循环语句"></a>2.3.3 循环语句</h4><ul>
<li>Shell 脚本中常会遇到一些重复任务，相当于循环执行一组命令直到满足了某个特定条件</li>
<li>常见的循环语句有3种：<code>for</code>、<code>while</code>、<code>until</code></li>
<li>循环控制符有两种：<code>break</code>、<code>continue</code>用于控制循环流程的转向</li>
</ul>
<h5 id="2-3-3-1-for循环"><a href="#2-3-3-1-for循环" class="headerlink" title="2.3.3.1 for循环"></a>2.3.3.1 for循环</h5><p>语法（Shell风格）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for var in list</span><br><span class="line">	do</span><br><span class="line">		commans</span><br><span class="line">	done</span><br><span class="line"></span><br><span class="line">e.g.</span><br><span class="line">for i in &#123;1..10&#125;</span><br><span class="line">	do</span><br><span class="line">		printf &quot;$i\n&quot;</span><br><span class="line">	done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>语法（C语言风格）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for ((var assignment ; condition ; iteration process))</span><br><span class="line">do</span><br><span class="line">commands</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for (( i = 1; i &lt; 10 ; i++))</span><br><span class="line">do</span><br><span class="line">echo “Hello”</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>do和done之间的命令称为循环体，执行次数和list列表中常数或字符串的个数相同。for循环，首先将in后list列表的第一个常数或字符串赋值给循环变量，然后执行循环体，以此执行list，最后执行done命令后的命令序列。</p>
<h5 id="2-3-3-2-for循环中的列表"><a href="#2-3-3-2-for循环中的列表" class="headerlink" title="2.3.3.2 for循环中的列表"></a>2.3.3.2 for循环中的列表</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@openeuler ~]# for HOST in host1 host2 host3; do echo $HOST; done</span><br><span class="line">host1</span><br><span class="line">host2</span><br><span class="line">host3</span><br><span class="line"></span><br><span class="line">[root@openeuler ~]# for HOST in host&#123;1..3&#125;; do echo $HOST; done</span><br><span class="line">host1</span><br><span class="line">host2</span><br><span class="line">host3</span><br><span class="line">[root@openeuler ~]# for EVEN in $(seq 2 2 8); do echo &quot;$EVEN&quot;; done;</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="2-3-3-3-for循环奇数累加器"><a href="#2-3-3-3-for循环奇数累加器" class="headerlink" title="2.3.3.3 for循环奇数累加器"></a>2.3.3.3 for循环奇数累加器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">sum=0</span><br><span class="line">for i in &#123;1..100..2&#125;</span><br><span class="line">do </span><br><span class="line">	let &quot;sum+=i&quot;</span><br><span class="line">done</span><br><span class="line">echo &quot;sum=$sum&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-3-3-4-for循环文件展示"><a href="#2-3-3-4-for循环文件展示" class="headerlink" title="2.3.3.4 for循环文件展示"></a>2.3.3.4 for循环文件展示</h5><ul>
<li>展示目录下所有文件</li>
<li>参考脚本：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">for file in $(ls)</span><br><span class="line">do</span><br><span class="line">	ehco &quot;file:$file&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-3-3-5-while循环"><a href="#2-3-3-5-while循环" class="headerlink" title="2.3.3.5 while循环"></a>2.3.3.5 while循环</h5><ul>
<li>也称为前测试循环语句，重复次数是利用一个条件来控制是否继续重复执行这个语句</li>
<li>为避免死循环，必须保证循环体中包含循环出口条件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin./bash</span></span><br><span class="line"></span><br><span class="line">sum=0;i=1</span><br><span class="line">while(i&lt;=100)</span><br><span class="line">do</span><br><span class="line">	let &quot;sum+=i&quot;</span><br><span class="line">	let &quot;i+=2&quot;</span><br><span class="line">done</span><br><span class="line">	echo &quot;sum=$sum&quot;</span><br></pre></td></tr></table></figure>
此处示例等同于此前奇数累加器，思考：与for循环实现方式相比有何不同?</li>
</ul>
<h5 id="2-3-3-6-until循环"><a href="#2-3-3-6-until循环" class="headerlink" title="2.3.3.6 until循环"></a>2.3.3.6 until循环</h5><p>与 while 循环类似，但是跳出循环的条件判断有所区别</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">奇数累加器</span></span><br><span class="line">sum=0;i=1</span><br><span class="line">until(( i &gt; 100 ))</span><br><span class="line">do</span><br><span class="line">let &quot;sum+=i&quot;</span><br><span class="line">let &quot;i += 2&quot;</span><br><span class="line">done</span><br><span class="line">echo &quot;sum=$sum&quot;</span><br></pre></td></tr></table></figure>
<p>此处示例脚本等同于此前奇数累加器<br>思考：与for循环,while循环实现方式相比有何不同？</p>
<h5 id="2-3-3-7-使用循环打印乘法表"><a href="#2-3-3-7-使用循环打印乘法表" class="headerlink" title="2.3.3.7 使用循环打印乘法表"></a>2.3.3.7 使用循环打印乘法表</h5><p>P440</p>
<p>参考脚本“</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">for (i=1;i&lt;=9;i++)do</span><br><span class="line">	for(j=1;j&lt;=9;j++)do</span><br><span class="line">		let &quot;temp=i*j&quot;</span><br><span class="line">		echo -n &quot;$i*$j=$temp&quot;</span><br><span class="line">		echo &quot;\t&quot;</span><br><span class="line">		done</span><br><span class="line">printf &quot;\n&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>


<h2 id="0x03-Shell编程最佳实践"><a href="#0x03-Shell编程最佳实践" class="headerlink" title="0x03 Shell编程最佳实践"></a>0x03 Shell编程最佳实践</h2><ul>
<li>掌握 bash 的调试模式</li>
<li>掌握 Shell 脚本的基本调试方法</li>
<li>了解 Shell 脚本编写过程中应遵循的良好风格</li>
<li>掌握常见脚本的编写方法</li>
</ul>
<hr>
<h3 id="3-1-调试"><a href="#3-1-调试" class="headerlink" title="3.1 调试"></a>3.1 调试</h3><h4 id="3-1-1-Shell-脚本错误故障排除"><a href="#3-1-1-Shell-脚本错误故障排除" class="headerlink" title="3.1.1 Shell 脚本错误故障排除"></a>3.1.1 Shell 脚本错误故障排除</h4><ul>
<li>编写、使用或维护 Shell 脚本的管理员不可避免地会遇到脚本的错误<ul>
<li>错误通常是由于输入错误、语法错误或脚本逻辑不佳导致</li>
<li>在编写脚本时,将文本编辑器与 bash 语法高亮显示结合使用可以帮助使错误更明显</li>
<li>找到并排除脚本中错误的最直接方法是调试</li>
<li>避免在脚本中引入错误的另一种简单方法是在创建脚本期间遵循良好风格</li>
</ul>
</li>
</ul>
<h4 id="3-1-2-调试模式"><a href="#3-1-2-调试模式" class="headerlink" title="3.1.2 调试模式"></a>3.1.2 调试模式</h4><ul>
<li><p>脚本上激活调试模式，请向脚本第一行中的命令解释器中添加<code>-x</code>选项</p>
</li>
<li><p>如此前乘法表，进行如下修改：<br><code>#!/bin/bash -x</code></p>
</li>
<li><p>bash 的调试模式将打印出脚本执行前由脚本执行的命令</p>
</li>
<li><p>已执行的所有 shell 扩展的结果都将显示在打印输出中，所有变量数据状态会实时打印，以供跟踪：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@openEuler tmp]# bash -x adder.sh</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/assets/08%20%E4%BD%BF%E7%94%A8shell%E8%84%9A%E6%9C%AC/2025020817-3530742.png"></p>
<h4 id="3-1-3-评估退出代码"><a href="#3-1-3-评估退出代码" class="headerlink" title="3.1.3 评估退出代码"></a>3.1.3 评估退出代码</h4><ul>
<li><p>每个命令返回一个退出状态，也通常称为返回状态或退出代码</p>
</li>
<li><p>退出代码可以用于脚本的调试</p>
</li>
<li><p>以下示例说明了几个常用命令的执行和退出状态检索</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@openEuler tmp]# ls /etc/hosts</span><br><span class="line">/etc/hosts</span><br><span class="line">[root@openEuler tmp]# echo $?</span><br><span class="line">0</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">[root@openEuler tmp]# ls /etc/nofile</span><br><span class="line">ls: cannot access /etc/nofile: No such file or directory</span><br><span class="line">[root@openEuler tmp]# echo $?</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
</li>
<li><p>在脚本中使用退出代码</p>
</li>
<li><p>一旦执行，脚本将在其处理所有内容之后退出，但是有时候可能需要中途退出脚本，比如在遇到错误条件时</p>
</li>
<li><p>可以通过在脚本中使用 exit 命令来实现这一目的，当脚本遇到 exit 命令时，脚本将立即退出并跳过对脚本其余内容的处理</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;Hello World&quot;</span><br><span class="line">exit 1</span><br><span class="line"></span><br><span class="line">[root@openEuler tmp]# ./hello.sh</span><br><span class="line">Hello World</span><br><span class="line">[root@openEuler tmp]# echo $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>


<h3 id="3-2-语法风格"><a href="#3-2-语法风格" class="headerlink" title="3.2 语法风格"></a>3.2 语法风格</h3><h4 id="3-2-1-良好风格"><a href="#3-2-1-良好风格" class="headerlink" title="3.2.1 良好风格"></a>3.2.1 良好风格</h4><ul>
<li>以下是要遵循的一些具体做法:<ul>
<li>将长命令分解为多行更小的代码块，代码段越短，就越便于读者领悟和理解</li>
<li>将多个语句的开头和结尾排好，以便于查看控制结构的开始和结束位置以及它们是否正确关闭</li>
<li>对包含多行语句的行进行缩进，以表示代码逻辑的层次结构和控制结构的流程</li>
<li>使用行间距分隔命令块以阐明一个代码段何时结束以及另一个代码段何时开始</li>
<li>在整个脚本中通篇使用一致的格式</li>
</ul>
</li>
<li>添加注释和空格如何能够极大改善脚本可读</li>
<li>利用这些简单做法，极大方便了用户在编写期间发现错误，还提高了脚本对于将来读者的可读性<br>脚本示例：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for PACKAGE in $(rpm -qa | grep kernel); do echo &quot;$PACKAGE was installed on $(date -d @$(rpm -q --qf &quot;%&#123;INSTALLTIME&#125;\n&quot; $PACKAGE))&quot;; done</span><br></pre></td></tr></table></figure>
修改后的脚本<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">此脚本是读取关于kernel相关的软件包信息，并从RPM数据库中查询软件包的安装时间</span></span><br><span class="line">PACKAGETYPE=kernel</span><br><span class="line">PACKAGES=$(rpm -qa | grep $PACKAGETYPE)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">循环处理信息</span></span><br><span class="line">for PACKAGE in $PACKAGES; do</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">查询每个软件包的安装时间</span></span><br><span class="line">INSTALLEPOCH=$(rpm -q --qf &quot;%&#123;INSTALLTIME&#125;\n&quot; $PACKAGE)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">把时间转换为普通的日期时间</span></span><br><span class="line">INSTALLDATETIME=$(date -d @$INSTALLEPOCH)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">打印信息</span></span><br><span class="line">echo &quot;$PACKAGE was installed on $INSTALLDATETIME&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-3-最佳实践范例"><a href="#3-3-最佳实践范例" class="headerlink" title="3.3 最佳实践范例"></a>3.3 最佳实践范例</h3><h4 id="3-3-1-监测日志告警信息并邮件通知"><a href="#3-3-1-监测日志告警信息并邮件通知" class="headerlink" title="3.3.1 监测日志告警信息并邮件通知"></a>3.3.1 监测日志告警信息并邮件通知</h4><ul>
<li><p>场景描述：</p>
<ul>
<li>某运营商要求对当前环境日志文件“error.log”进行长期监测，如发现关键词“danger”，则发送告警邮件</li>
</ul>
</li>
<li><p>要求：</p>
<ul>
<li>日志文件可自己新建，用脚本模拟写入</li>
<li>发送邮件可通过mail指令，但受限实验环境，可通过向日志文件写入”mail”字符串来替代</li>
<li>实现效果：<br><img src="/assets/08%20%E4%BD%BF%E7%94%A8shell%E8%84%9A%E6%9C%AC/2025020822-1035999.png"></li>
</ul>
</li>
<li><p>后台运行监测脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.sh &amp;</span><br></pre></td></tr></table></figure></li>
<li><p>模拟报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./addlog.sh</span><br></pre></td></tr></table></figure></li>
<li><p>查看<code>error.log</code>文件，检查结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/error.log</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">日志检测脚本test.sh</span></span><br><span class="line"></span><br><span class="line">tail -f /var/log/error.log | while read danger;</span><br><span class="line">do echo &#x27;mail&#x27; &gt;&gt; /var/log/error.log</span><br><span class="line">sleep 1m;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">模拟报错脚本addlog.sh</span></span><br><span class="line">echo &#x27;danger&#x27; &gt;&gt; /var/log/error.log</span><br></pre></td></tr></table></figure>

<h2 id="0x04-本章总结"><a href="#0x04-本章总结" class="headerlink" title="0x04 本章总结"></a>0x04 本章总结</h2><ul>
<li>本章系统介绍了 Shell 脚本中的各个要素，包括执行、编写、调试</li>
<li>在执行部分，介绍了工作中常用的前台、后台运行方式及对应操作</li>
<li>在编写部分，介绍了编写 Shell 脚本所需的变量、语句结构等知识</li>
<li>在调试部分，介绍了常见的调试方法和编写过程中良好风格</li>
<li>本章提供了大量的实际案例和示例代码，有助于实际工作中的使用</li>
</ul>
<h2 id="0x05-Shell脚本的一些注意点"><a href="#0x05-Shell脚本的一些注意点" class="headerlink" title="0x05 Shell脚本的一些注意点"></a>0x05 Shell脚本的一些注意点</h2><ul>
<li>在 Bash 中，变量赋值时，等号两边不能有空格。</li>
<li>在 Bash 中，<code>$()</code> 是用于命令替换的语法。它允许你将命令的输出结果作为表达式的一部分，并将其赋值给一个变量，或者在其他命令中使用。</li>
</ul>
<h3 id="为什么需要使用-？"><a href="#为什么需要使用-？" class="headerlink" title="为什么需要使用 $()？"></a>为什么需要使用 <code>$()</code>？</h3><ol>
<li><p><strong>获取命令输出</strong>： <code>$()</code> 用于获取命令的输出并将其替换到变量或其他表达式中。换句话说，<code>$()</code> 是一种将命令的标准输出嵌入到其他命令或赋值中的方式。</p>
</li>
<li><p><strong>防止语法错误</strong>： 如果没有 <code>$()</code> 或者反引号  ，Bash 会将整个命令当作普通的字符串处理，而不是执行它。</p>
</li>
</ol>
<p>假设你想将当前的日期赋给变量 <code>day_of_week</code>，你可以使用以下代码：</p>
<p><code>day_of_week=$(date)</code></p>
<p>这行代码会执行 <code>date</code> 命令，并将 <code>date</code> 命令的输出结果（当前的日期和时间）赋值给变量 <code>day_of_week</code>。</p>
<p>如果不使用 <code>$()</code> 会发生什么？</p>
<p>如果你省略 <code>$()</code>，Bash 就会把 <code>date</code> 作为一个普通的字符串处理，而不会执行它：</p>
<p>bash复制代码</p>
<p><code>day_of_week=date</code></p>
<p>这时，变量 <code>day_of_week</code> 会被赋值为字符串 <code>&quot;date&quot;</code>，而不是 <code>date</code> 命令的输出结果。</p>
<h3 id="另一种命令替换的方式：反引号（-）"><a href="#另一种命令替换的方式：反引号（-）" class="headerlink" title="另一种命令替换的方式：反引号（````）"></a>另一种命令替换的方式：反引号<code>（````）</code></h3><p>除了 <code>$()</code>，你还可以使用反引号来进行命令替换：</p>
<p>bash复制代码</p>
<p><code>day_of_week=`date`</code></p>
<p>但是，反引号有一些局限性：</p>
<ul>
<li>嵌套命令时会变得非常难以读取。例如，<code>date +%Y-%m-%d</code> 里面包含反引号时就会变得很难维护。</li>
<li>使用 <code>$()</code> 更加现代和可读，特别是对于复杂命令。</li>
</ul>
<p>总结：</p>
<p><code>$()</code> 用于在 Bash 脚本中执行命令并<strong>捕获其输出</strong>。没有它，Bash 就无法知道你要执行的命令，并且会把它当作普通字符串处理。</p>
<h3 id="方括号的使用"><a href="#方括号的使用" class="headerlink" title="方括号的使用"></a>方括号的使用</h3><p>方括号中使用表达式 表达式需要与方括号之间有空格 否则会错误</p>
	
		</div>
		
		<div id="current-post-cover" data-scr="/img/cart_cover.jpg"></div>

		<!-- relate post, comment...-->
		<div class="investment-container">
			<div class="investment-header">
				<div class="investment-title-1">
					<div class="on">相关文章</div>
					<div>评论</div>
					<div>分享</div>
				</div>
				<div class="investment-title-2">	            
					
	<span>
		<a id="totop-post-page">返回顶部</a>
		
			<a href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IA/09%20Samba%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/" title="09 Samba文件共享服务器管理" rel="prev">
				&laquo;上一篇
			</a>
		
		
			<a href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IA/06%20%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%AD%98%E5%82%A8/" title="06 管理文件系统及存储" rel="next">
				下一篇&raquo;
			</a>
			
	</span>


      		
				</div>	
			</div>
			
			<div class="investment-content">
				<div class="investment-content-list">
					

<div class="relate-post">
	
		<ul>
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IA/09%20Samba%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/" title="09 Samba文件共享服务器管理">
								09 Samba文件共享服务器管理			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 19日, 2025				
							</p>
							<p class="relate-post-content">
								完成openEuler系统基础命令操作后，可以基于openEuler及软件搭建各类服务，应用到各个IT系统中，基于openEuler及Samba可以完成文件共享服务器的搭建。
学完本课程后，你将能够:

基于openEuler系统文件...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IA/09%20Samba%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/" title="09 Samba文件共享服务器管理">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="09 Samba文件共享服务器管理"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IA/06%20%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%AD%98%E5%82%A8/" title="06 管理文件系统及存储">
								06 管理文件系统及存储			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 19日, 2025				
							</p>
							<p class="relate-post-content">
								本章主要讲述文件系统、磁盘存储、逻辑卷存储的基础概念以及如何管理、使用文件系统和存储，以及对一些常用操作命令的介绍。
学完本课程后，您将能够：

了解文件系统及存储的基本概念
掌握磁盘存储的挂载和使用方法
掌握逻辑卷的管理方法


0...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IA/06%20%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%AD%98%E5%82%A8/" title="06 管理文件系统及存储">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="06 管理文件系统及存储"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IA/05%20%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%B9%B6%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1/" title="05 安装软件并管理服务">
								05 安装软件并管理服务			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 19日, 2025				
							</p>
							<p class="relate-post-content">
								本章节主要讲述openEuler中安装软件包三种方式：rpm安装、源码安装以及yum安装的相关概念以及具体的操作命令，并且介绍了systemd管理服务的概念以及操作方式。
0x01 RPM管理软件包1.1 RPM软件包Linux软件包...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IA/05%20%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%B9%B6%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1/" title="05 安装软件并管理服务">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="05 安装软件并管理服务"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IP/03%20openEuler%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/" title="03 openEuler存储管理">
								03 openEuler存储管理			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 19日, 2025				
							</p>
							<p class="relate-post-content">
								存储是计算机系统中非常重要的概念，它负责存储和管理数据。随着IT技术的不断发展和企业对存储需求的不断变化，存储技术和架构也在不断革新。本章我们将从存储的基本概念开始了解不同存储类型的区别及使用方法。
学完本课程后，您将能够:

了解存...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IP/03%20openEuler%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/" title="03 openEuler存储管理">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="03 openEuler存储管理"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2025/03/08/openEuler/%E7%AC%94%E8%AE%B0/IP/06%20openEuler%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/" title="06 openEuler操作系统安全加固">
								06 openEuler操作系统安全加固			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								三月 8日, 2025				
							</p>
							<p class="relate-post-content">
								操作系统是互联网不可或缺的基础设施之一，也是生产、处理和存储价值数据的实体。同时openEuler作为Linux发行版系统，具有开源、免费的特点，拥有丰富健康的生态环境和社区支持。正因如此，保障其安全的重要性不言而喻。本章节以操作系统...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2025/03/08/openEuler/%E7%AC%94%E8%AE%B0/IP/06%20openEuler%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/" title="06 openEuler操作系统安全加固">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="06 openEuler操作系统安全加固"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2025/03/06/openEuler/%E7%AC%94%E8%AE%B0/IP/05%20shell%E8%84%9A%E6%9C%AC%E8%BF%9B%E9%98%B6/" title="05 shell脚本进阶">
								05 shell脚本进阶			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								三月 6日, 2025				
							</p>
							<p class="relate-post-content">
								前言本章主要讲述Shell脚本的进阶功能，包括条件判断、函数、正则表达式、grep、sed、awk命令。

掌握条件判断的使用
掌握函数的常见操作
掌握grep语法与常见操作
掌握正则表达式的基本用法
掌握sed语法与常见操作
掌握a...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2025/03/06/openEuler/%E7%AC%94%E8%AE%B0/IP/05%20shell%E8%84%9A%E6%9C%AC%E8%BF%9B%E9%98%B6/" title="05 shell脚本进阶">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="05 shell脚本进阶"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2025/03/04/openEuler/%E7%AC%94%E8%AE%B0/IP/02%20openEuler%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/" title="02 openEuler集群架构介绍">
								02 openEuler集群架构介绍			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								三月 4日, 2025				
							</p>
							<p class="relate-post-content">
								前言随着互联网的发展，单机应用已经无法满足用户的需求，因此集群应用而生本章将主要介绍高可用集群与负载均衡集群的实现工具的配置，包括LVS、HAProxy、Nginx和Keepalived 。目标

熟悉LVS的搭建和配置
熟悉Ngin...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2025/03/04/openEuler/%E7%AC%94%E8%AE%B0/IP/02%20openEuler%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/" title="02 openEuler集群架构介绍">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="02 openEuler集群架构介绍"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2025/03/04/openEuler/%E5%AE%9E%E9%AA%8C/IP/02%20openEuler%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/01%20LVS%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/" title="01 LVS配置实践">
								01 LVS配置实践			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								三月 4日, 2025				
							</p>
							<p class="relate-post-content">
								1.1 LVS&#x2F;NAT 模式配置1.1.1 实验介绍本实验将通过 LVS 负载均衡的方式访问一个 Nginx 集群。在实际工作场景中，集群向外提供服务时显示的内容是一致的，但在本实验中为了将 LVS 的算法体现的比较明显，N...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2025/03/04/openEuler/%E5%AE%9E%E9%AA%8C/IP/02%20openEuler%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/01%20LVS%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/" title="01 LVS配置实践">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="01 LVS配置实践"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2025/03/02/openEuler/%E5%AE%9E%E9%AA%8C/IP/01%20openEuler%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1/03%20DNS%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/" title="03 DNS相关配置">
								03 DNS相关配置			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								三月 2日, 2025				
							</p>
							<p class="relate-post-content">
								3.1 实验介绍3.1.1 关于本实验本实验基于《3.3.2 Nginx 负载均衡配置》进行，将使用 DNS 服务器代替原先的静态 DNS 为用户端提供对应服务。
3.2 安装 DNS 软件3.2.1 资源准备按照实验组网介绍和实验设...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2025/03/02/openEuler/%E5%AE%9E%E9%AA%8C/IP/01%20openEuler%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1/03%20DNS%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/" title="03 DNS相关配置">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="03 DNS相关配置"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2025/02/28/openEuler/%E5%AE%9E%E9%AA%8C/IA/08%20shell%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" title="08 shell脚本语言基础">
								08 shell脚本语言基础			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								二月 28日, 2025				
							</p>
							<p class="relate-post-content">
								8.1 实验介绍8.1.1 实验介绍在对系统进行运维时，shell 脚本给了我们很大帮助。通过 shell 脚本，可以大大减少工作量。本实验主要介绍 shell 脚本的概念及使用。
8.1.2 实验目标
掌握全局变量及局部变量；
掌握...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2025/02/28/openEuler/%E5%AE%9E%E9%AA%8C/IA/08%20shell%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" title="08 shell脚本语言基础">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="08 shell脚本语言基础"/>
							</a>
						</div>
					</li>												
			
		</ul>
	
</div>	
				</div>
				<div class="investment-content-list">
					<div class="layout-comment">

	
		<div class="config-info">
			Please check the parameter of <b>comment</b> in config.yml of hexo-theme-Annie!
		</div>	
	

</div>
				</div>
				<div class="investment-content-list">
					<div class="layout-share">
	
	

		
			
			<!-- socialShare share -->
			<div class="social-share"></div>

<!--  css & js -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
<script async src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
			
		
		
	
</div>


				</div>
			</div>	
		</div>
	</div>
</div>

<!-- show math formula -->



	





<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">


<script src="/plugin/fancybox/jquery.fancybox.js"></script>


<script type="text/javascript">
	(function gallerySet(){
		let titleID = $('.article-title a'),
			imageID = $('.article-content img'),
			videoID = $('.article-content video');
		
		let postTitle = titleID.text() ? titleID.text() : "No post title!";
		
		imageID.each(function() {
			let imgPath = $(this).attr('src'),
				imgTitle = $(this).attr('alt') ? $(this).attr('alt') : "No image description!";
		
			//给每个匹配的<img>元素打包, 即添加父元素<a>
			$(this).wrap('<a data-fancybox="gallery" data-caption="《 ' + postTitle + ' 》' + imgTitle + '"href="' + imgPath + '"> </a>');
		});
		
		videoID.each(function() {
			let videoPath = $(this).attr('src');
		
			//给每个匹配的<img>元素打包, 即添加父元素<a>
			$(this).wrap('<a data-fancybox href=" ' + videoPath + ' "> </a>');
		});
		
		//TODO：支持html5 video

		if($('#layout-post').length) {
			$('[data-fancybox="gallery"]').fancybox({
				loop: true,
				buttons: [
					"zoom",
					"share",
					"slideShow",
					"fullScreen",
					//"download",
					"thumbs",
					"close"
				],
				protect: true
			});
		}
	})();
</script>
		</main>

		<!--footer-->
		<footer>
	<div id="navigation-show">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories" target="_blank">分类</a>
		</li>
		
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags" target="_blank">标签</a>
		</li>
		
	
		<li class="menu-about">
			<a href="/about" class="menu-item-about" target="_blank">关于</a>
		</li>
		
	
		<li class="menu-gallery">
			<a href="/gallery" class="menu-item-gallery" target="_blank">相册</a>
		</li>
		
	

	
</ul>
	</div>

	<div class="copyright">
		<p>
			 
				&copy;2017 - 2025, content by Sariay. All Rights Reserved.
			
			
				<a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> Theme <a href="https://github.com/Sariay/hexo-theme-Annie" title="Annie" target="_blank" rel="noopener">Annie</a> by Sariay.
			
		</p>
		<p>
			

	<!-- busuanzi -->
	<!-- busuanzi -->



			<a href="javascript:zh_tran('s');" class="zh_click" id="zh_click_s">简体</a> 
			<a href="javascript:zh_tran('t');" class="zh_click" id="zh_click_t">繁體</a>				
		</p>
	</div>		
</footer>
		
	<!-- Local or hitokoto! -->

	
<script src="/plugin/motto/motto.js"></script>

	
	<script type="text/javascript">
		(function motto(){
			let mottoText = getMingYanContent().split('</br> - </br>'),
			
			mottoTextContent = mottoText[0]?mottoText[0]:'请刷新...',
			
			mottoTextFrom = mottoText[1]?mottoText[1]:'one/一个';
			
			mottoTextContent = mottoTextContent.trim().substring(0, 100);
		
			$("#motto-content").html( mottoTextContent);
			$("#motto-author").html( mottoTextFrom  );
		})();	
	</script>	



<!-- love effect -->


<!-- back to top -->

	<div id="totop">
	<span class="icon-circle-up"></span>
</div>



<!-- site analysis -->


	<!-- site-analysis -->
	
	
	
	
	
 

<!-- leancloud -->


	<!-- leancloud -->
	<!--
	时间：2018-11-27
	描述：
		文章访问量：visitors
		文章喜欢量：likes	
		文章排行榜：topNPost
		其他得说明：
			01-Cookie相关的函数 
				https://blog.csdn.net/somehow1002/article/details/78511541（Author：somehow1002）
			02-visitors相关的函数 
				https://blog.csdn.net/u013553529/article/details/63357382（Author：爱博客大伯）
				https://notes.doublemine.me/2015-10-21-为NexT主题添加文章阅读量统计功能.html（Author：夏末）
			03-topNPost相关的函数
				https://hoxis.github.io/hexo-next-read-rank.html（Author：hoxis）
			04-likes相关的函数，
				参考了01 & 02进行简单的设计与实现
-->


	

  



<script src="/plugin/chinese/chinese.js"></script>
<script src="/plugin/imagelazyloader/yall.min.js"></script>
<script src="/plugin/imageloaded/imagesloaded.pkgd.min.js"></script>
<script src="/plugin/nicescroll/jquery.nicescroll.js"></script>
<script src="/plugin/resizediv/resizediv.js"></script>
<script src="/js/main.js"></script>

	</body>	
</html>