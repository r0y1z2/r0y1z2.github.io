<!--
	作者：Sariay
	时间：2018-08-26
	描述：There may be a bug, but don't worry, Qiling(器灵) says that it can work normally! aha!
-->
<!DOCTYPE html>
<html class="html-loading">
		

<head>
	<meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <title>
    
      03 openEuler存储管理 | XBCID&#39;s BLOG
    
  </title>
  <meta name="author" content="XBCID">
  <meta name="keywords" content="" />
  <meta name="description" content="" />
	<!-- favicon -->
  <link rel="shortcut icon" href="/img/favicon.ico">

  <!-- css -->
  
<link rel="stylesheet" href="/css/Annie.css">

  
  <!-- jquery -->
	
<script src="/plugin/jquery/jquery.min.js"></script>


<script>
    const CONFIG_BGIMAGE = {
      mode: 'normal',
      normalSrc: '/img/header-bg.jpg',
      randomYouMax: 110,
      randomYouSrc: 'https://sariay.github.io/Random-img/',
	  randomOtherSrc: 'https://api.berryapi.net/?service=App.Bing.Images&day=-0',
	  preloaderEnable: true
    }
	
    const CONFIG_LEACLOUD_COUNT = {
      enable: false,
	  appId: 'AU8...',
	  appKey: '4cU...',
	  serverURLs: 'http' || ' '
    }
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>
	<body>
		<!-- Preloader -->

	<div id="preloader">
		<div class="pre-container">
			
				<div class="spinner">
					<div class="double-bounce1"></div>
					<div class="double-bounce2"></div>
				</div>
						
		</div>
	</div>


<!-- header -->
<header class="fixbackground bg-pan-br">
	<div class="mask">
		<!-- motto -->
		<div class="h-body">	
			
				<div class="motto text-shadow-pop-left">
					<p class="content" id="motto-content">获取中...</p>
					<p>-<p>
					<p class="author" id="motto-author">Just a minute...</p>
				</div>
			
		</div>
		
		<!-- others: such as time... -->			
		<div class="h-footer">
			<a href="javascript:;" id="read-more" class="scroll-down">
				<span class="icon-anchor1 animation-scroll-down"></span>
			</a>
		</div>
	</div>
</header>

<div id="navigation-hide">
	<!-- Progress bar -->
	<div id="progress-bar"></div>

	<!-- Progress percent -->
	<div id="progress-percentage"><span>0.0%</span></div>

	<div class="toc-switch"><span class="switch-button">目录</span></div>

	<!-- Page title -->
	<p>
		
			「03 openEuler存储管理」
		
	</p>

	
	

	<!-- Nav trigger for navigation-H-->
	<a class="nav-trigger"><span></span></a>
</div>

<!-- Navigation in div(id="navigation-H") -->
<nav class="nav-container" id="cd-nav">
	<div class="nav-header">
		<span class="logo"> 
			<img src="/img/logo.png">
		</span>
		<a href="javascript:;" class="nav-close"></a>
	</div>
	
	<div class="nav-body">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories" target="_blank">分类</a>
		</li>
		
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags" target="_blank">标签</a>
		</li>
		
	
		<li class="menu-about">
			<a href="/about" class="menu-item-about" target="_blank">关于</a>
		</li>
		
	
		<li class="menu-gallery">
			<a href="/gallery" class="menu-item-gallery" target="_blank">相册</a>
		</li>
		
	

	
</ul>
	</div>
	
	<div class="nav-footer">
		<ul id="global-social">
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-one"><span class="path1"></span><span class="path2"></span></span>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-zhihu"></span>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-github"></span>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-sina-weibo "></span>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-pinterest2"></span>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-instagram"></span>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<span class="icon-twitter"></span>
			</a>
		</li>
	
		<li>
			<a href="/atom.xml" target="_blank">
				<span class="icon-rss"></span>
			</a>
		</li>
			
</ul>

	</div>
</nav>
			
		<!--main-->
		<main>
			<!--
	时间：2018-11-17
	描述：
		插件名称：katelog.min.js
		插件作者：KELEN
		插件来源: https://github.com/KELEN/katelog
-->

	
		<div class="layout-toc">
			<div id="layout-toc">
				<div class="k-catelog-list" id="catelog-list" data-title="文章目录"></div>
			</div>
		</div>

		
<script src="/plugin/toc/katelog.min.js"></script>


		
	 

<div class="layout-post">
	<div id="layout-post">
		<div class="article-title">
			
	<a href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IP/03%20openEuler%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/" itemprop="url">
		03 openEuler存储管理
	</a>

		</div>

		<div class="article-meta">
			<span>
				<i class="icon-calendar1"></i>
				
				




	更新于

	<a href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IP/03%20openEuler%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/" itemprop="url">
		<time datetime="2025-05-18T19:42:00.000Z" itemprop="dateUpdated">
	  		2025-05-19
	  </time>
	</a> 



			</span>
			<span>
				
	<i class="icon-price-tags"></i>
	
		<a href="/tags/Linux/" class=" ">
			Linux
		</a>
	
		<a href="/tags/openEuler/" class=" ">
			openEuler
		</a>
	
		<a href="/tags/HCIP/" class=" ">
			HCIP
		</a>
	
		<a href="/tags/Huawei/" class=" ">
			Huawei
		</a>
	
		
			</span>
			
			



		</div>

		<div class="article-content" id="article-content">
			<p>存储是计算机系统中非常重要的概念，它负责存储和管理数据。随着IT技术的不断发展和企业对存储需求的不断变化，存储技术和架构也在不断革新。本章我们将从存储的基本概念开始了解不同存储类型的区别及使用方法。</p>
<p>学完本课程后，您将能够:</p>
<ul>
<li>了解存储的基本概念和类型</li>
<li>掌握NAS的基本原理和使用方法</li>
<li>掌握SAN的不同类型及使用场景</li>
<li>掌握GlusterFs的基本原理及常见卷模式</li>
</ul>
<h2 id="0x01-存储的基本概念"><a href="#0x01-存储的基本概念" class="headerlink" title="0x01 存储的基本概念"></a>0x01 存储的基本概念</h2><h3 id="1-什么是数据"><a href="#1-什么是数据" class="headerlink" title="1. 什么是数据"></a>1. 什么是数据</h3><p>全球网络存储工业协会)对数SNIA( Storage Networking Industry Association）数据的定义:数据是对所有事物的数字表示<br><img src="/file-20250505113707428.png"></p>
<ul>
<li>数据是指描述客观事物的符号记录，是未经加工的原始材料。一组数字，一段文字，一张图片等都可以视为数据</li>
<li>在计算机的世界里，只有0和1。所有要保存在计算机中，需要读写的数据都可以用一串由0和1组成的数字表示</li>
</ul>
<h3 id="2-什么是信息"><a href="#2-什么是信息" class="headerlink" title="2. 什么是信息"></a>2. 什么是信息</h3><ul>
<li>信息是已经被处理、具有逻辑关系的数据，是对数据的解释</li>
<li>信息是经过处理的数据，其中包括具有上下文，相关性和目的的数据</li>
<li><img src="/file-20250505113828920.png"></li>
<li>信息是指从数据中提取出来的有用的知识或意义</li>
<li>数据冗余就是无用或无意义的内容</li>
</ul>
<h3 id="3-存储介绍"><a href="#3-存储介绍" class="headerlink" title="3. 存储介绍"></a>3. 存储介绍</h3><h4 id="3-1-存储基本介绍"><a href="#3-1-存储基本介绍" class="headerlink" title="3.1 存储基本介绍"></a>3.1 存储基本介绍</h4><p>数据文件&#x2F;信息需要通过电子设备进行存储，这就是数据存储，简称存储<br><img src="/file-20250505114030147.png"></p>
<ul>
<li>名词存储是指计算机系统中用户保存数据和信息的介质。它可以是硬件设备，如硬盘、固态硬盘、U盘等，也可以是软件系统，如云存储和数据库等</li>
<li>动词存储是将数据或信息保存在一个物理设备中的过程，如硬盘、闪存、内存等。这些设备可以长期保存信息，即使电脑关闭或断电，数据也不会丢失</li>
<li>存储可以分为内部存储和外部存储，内部存储通常指计算机内部的存储器，例如硬盘、固态硬盘、内存等；而外部存储则指通过外部设备进行数据存储，例如USB、外置硬盘、光盘等</li>
<li>存储的基本载体–硬盘。原始的存储方法也包括纸质存储和磁带存储等</li>
<li>根据存储介质分类：<ul>
<li>硬盘存储</li>
<li>固态硬盘存储</li>
<li>光盘存储</li>
<li>磁带存储</li>
<li>云存储</li>
</ul>
</li>
</ul>
<h4 id="3-2-存储架构的演进"><a href="#3-2-存储架构的演进" class="headerlink" title="3.2 存储架构的演进"></a>3.2 存储架构的演进</h4><p><img src="/file-20250505114157899.png"></p>
<ul>
<li>最早的存储设备为打孔纸带等，计算机&#x2F;服务器普及开始，内部硬盘是存储架构演进的初始</li>
<li>单存储时代：硬盘作为服务器内置存储，由于主机内部空间导致磁盘容量受限，影响性能提升，直连存储技术DAS出现。早期企业数据规模不大，存储需求简单，外部数据存储设备直接挂在服务器内部总线上，可以解决单台服务器存储扩展、高性能传输的需求</li>
<li>集中式存储时代：企业规模增加，存储需求增大，服务器和存储独立，资源利用率较低，需要在不同操作系统间共享文件和应用，并提高存储的扩展性，DAS提供的单机存储空间逐渐无法满足业务需求，依托于局域网络的网络存储设备解决方案出现</li>
<li>分布式存储时代：随着互联网的加速发展及云计算技术诞生，数据形态复杂多样、规模爆发式增长，对存储系统的弹性扩展和异构化需求急剧增加，分布式管理软件将若干存储节点的存储空间整合到一起，为前端应用服务器提供统一空间，有效解决海量数据搞扩展需求，降低成本</li>
<li>根据访问方式分类<ul>
<li>直接存储：固定存储介质，需要物理接触存储介质才能读取数据，如硬盘、光 盘等</li>
<li>网络存储：基于网络存储协议进行传输和访问，如网络磁盘、NAS等</li>
<li>分布式存储：数据存储在多个地方，通过网络进行统一管理和访问，如分布式</li>
<li>文件系统、分布式数据库等</li>
</ul>
</li>
</ul>
<h2 id="0x02-存储的分类"><a href="#0x02-存储的分类" class="headerlink" title="0x02 存储的分类"></a>0x02 存储的分类</h2><h3 id="2-1-存储分类-使用方式"><a href="#2-1-存储分类-使用方式" class="headerlink" title="2.1 存储分类 - 使用方式"></a>2.1 存储分类 - 使用方式</h3><p>存储按照使用方式可分为:</p>
<ul>
<li>共享存储，一台存储设备供给多台服务器使用，大多数情况下，充当共享存储的设备有:<ul>
<li>SAN</li>
<li>NAS</li>
<li>分布式存储</li>
</ul>
</li>
<li>独享存储，存储设备或介质仅供一台服务器使用，一般情况，充当独享存储的设备有:<ul>
<li>服务器自带硬盘</li>
<li>直连存储</li>
</ul>
</li>
</ul>
<h3 id="2-2-存储分类-数据存储方式"><a href="#2-2-存储分类-数据存储方式" class="headerlink" title="2.2 存储分类 - 数据存储方式"></a>2.2 存储分类 - 数据存储方式</h3><p><img src="/file-20250505153850247.png"></p>
<ul>
<li>块存储<ul>
<li>将裸磁盘空间整个映射给主机使用，操作系统还需要对挂载的裸硬盘进行分区、格式化后，才能使用</li>
</ul>
</li>
<li>文件存储<ul>
<li>文件存储一般体现形式是目录和文件（比如C:\Users\Downloads\text.doc），数据以文件的方式存储和访问，按照目录结构进行组织</li>
</ul>
</li>
<li>对象存储</li>
<li>对象存储的体现形式为URL（比如<code>https://www.abc.com/app?v=nAKxJbcec8U</code>），数据和元数据打包在一起作为一个整体对象存在一个超大池子里</li>
</ul>
<h3 id="2-3-存储分类-存储介质存放位置"><a href="#2-3-存储分类-存储介质存放位置" class="headerlink" title="2.3 存储分类 - 存储介质存放位置"></a>2.3 存储分类 - 存储介质存放位置</h3><p><img src="/file-20250505160024350.png"></p>
<ul>
<li>集中式存储是指将数据存储在由一台或者多台主机组成的中心节点（存储池）上。集中式存储所有的业务均集中部署在中心节点上，中心节点统一管理各分部节点的数据，按需分配，数据访问仅需经过一个控制器即可实现。</li>
<li>集中式存储包括 DAS、NAS、SAN ，可以根据不同的数据存储需求选择不同的存储类型。</li>
<li>分布式存储是指通过网络使用企业中多台机器上的磁盘空间，这些分散的存储资源构成了虚拟存储设备，数据分布存储在企业的各个角落。</li>
</ul>
<h2 id="0x03-共享存储介绍"><a href="#0x03-共享存储介绍" class="headerlink" title="0x03 共享存储介绍"></a>0x03 共享存储介绍</h2><h3 id="3-1-NAS"><a href="#3-1-NAS" class="headerlink" title="3.1 NAS"></a>3.1 NAS</h3><h4 id="3-1-1-NAS简介"><a href="#3-1-1-NAS简介" class="headerlink" title="3.1.1 NAS简介"></a>3.1.1 NAS简介</h4><ul>
<li><p>NAS（Network-attached Storge,网络接入存储）具有以下特点：</p>
<ul>
<li>共享存储</li>
<li>文件存储</li>
</ul>
</li>
<li><p><img src="/file-20250505160257889.png"></p>
</li>
<li><p>NAS（Network-attached Storage，网络接入存储）一种基于网络的存储设备，它提供了一种简单、安全、可扩展的方法来共享文件和存储数据</p>
</li>
<li><p>NAS网络通常由一个或多个硬盘驱动器组成，这些驱动器通过网络连接到一台或多台服务器或客户端设备，以提供存储空间</p>
</li>
<li><p>NAS的架构通常是以一个中央存储设备为核心，该设备连接到网络并与其他设备进行通信。这个存储设备通常由一台专用的NAS服务器或嵌入式系统来控制，它能够自动管理和备份数据，并提供一个简单易用的用户界面，以便用户可以访问和共享数据</p>
</li>
<li><p>NAS的架构还包括一些其他组件，如存储协议（如SMB、NFS、iSCSI等）和网络接口，以便不同的设备能够连接到NAS设备并进行数据交换。此外，还有一些管理工具和安全措施，以确保数据安全性和完整性</p>
</li>
</ul>
<h4 id="3-1-2-NAS架构"><a href="#3-1-2-NAS架构" class="headerlink" title="3.1.2 NAS架构"></a>3.1.2 NAS架构</h4><p>NAS设备包括</p>
<ul>
<li>NAS引擎(CPU和内存等)</li>
<li>一个或多个网络接口卡</li>
<li>一个操作系统，用于NAS功能管理</li>
<li>网络文件系统协议。</li>
<li>工业标准存储协议的磁盘资源</li>
</ul>
<p><img src="/file-20250505162407805.png"></p>
<h4 id="3-1-3-NAS常见协议"><a href="#3-1-3-NAS常见协议" class="headerlink" title="3.1.3 NAS常见协议"></a>3.1.3 NAS常见协议</h4><ul>
<li>CIFS(Common lnternet File system)，通用网络文件系统，是由微软的SMB(Server Message Block)发展而来的一个公共、开放的文件系统。在Windows主机之间，可以通过一个<strong>简单的共享映射</strong>，将CIFS服务器上的共享资源挂载到自己的系统中，把它当成自己本地系统资源一样来使用</li>
<li>NFS(Network File System)，网络文件系统，是由sun公司开发的，用于Linux&#x2F;UNIX&#x2F;AIX&#x2F;HP-UX&#x2F;Mac OS X等类UNIX的操作系统中实现网络文件共享。通过挂载命令将远程的文件系统<strong>挂载在自己的文件系统</strong>之下，像使用本机文件一样使用远程共享文件</li>
</ul>
<p><img src="/file-20250505162522779.png"></p>
<ul>
<li>NFS：Network File System protocol，传统的UNIX环境文件共享协议</li>
<li>CIFS：Common Internet File System protocol，传统的微软环境下的文件共享协议，基于服务器消息块协议</li>
<li>CIFS是一个基于网络的共享协议，其对网络传输的可靠性要求很高，所以它通常是使用TCP&#x2F;IP。NFS用于独立的传输，所以它使用TCP或UDP</li>
<li>NFS的一个缺点是客户端必须配备专用软件。CIFS被集成到操作系统中，不需要额外的软件</li>
<li>NFS是一个无状态的协议，而CIFS是一个有状态的协议。NFS连接故障后可自动恢复连接，而CIFS不能。CIFS仅发送少许的冗余信息，因此它具有比NFS更高的传输效率</li>
</ul>
<h4 id="3-1-4-NAS的特点"><a href="#3-1-4-NAS的特点" class="headerlink" title="3.1.4 NAS的特点"></a>3.1.4 NAS的特点</h4><ul>
<li>NAS通过文件级的数据访问和共享提供存储资源，使客户能够以最小的存储管理开销快速直接共享文件</li>
<li>NAS无需建立多个文件服务器</li>
<li>NAS利于消除用户访问通用服务器时的瓶颈</li>
<li>NAS使用网络和文件共享协议进行归档和存储</li>
</ul>
<p>NAS 的优点：</p>
<ul>
<li>横向扩展功能：为NAS增加存储容量就和增加硬盘一样简单。不必升级或更换现有的服务器，即可在不中断网络的情况下启用新的存储</li>
<li>高性能：由于NAS专门用于提供文件服务，所以其他联网设备无需再提供文件服务。由于NAS会针对具体用例（如大数据或多媒体存储）进行精调，所以客户可以获得更好的性能</li>
<li>易于设置：NAS架构往往会通过经简化的脚本来交付，或以简化版操作系统的预安装设备的形式来交付，因而可以大幅缩短存储的设置时间和系统的管理时间</li>
<li>可访问性：所有联网设备都可以访问NAS</li>
<li>容错性：可以对NAS进行格式化，以支持复制磁盘、独立磁盘冗余阵列或纠删码，进而确保数据的完整性</li>
</ul>
<h4 id="3-1-5-NAS的使用场景"><a href="#3-1-5-NAS的使用场景" class="headerlink" title="3.1.5 NAS的使用场景"></a>3.1.5 NAS的使用场景</h4><ul>
<li>家庭存储：适用于家庭用户存储家庭影音、照片等大量数据</li>
<li>小型企业存储：适用于小型企业存储和共享文件、数据备份和恢复等</li>
<li>远程办公：NAS存储支持远程访问和管理，适用于远程办公人员存储和共享数据</li>
<li>多媒体存储：适用于存储和共享音频、视频等多媒体数据，可以作为家庭影音中心</li>
<li>数据备份：适用于数据备份和恢复，确保数据的安全性和可靠性</li>
</ul>
<h3 id="3-2-NFS"><a href="#3-2-NFS" class="headerlink" title="3.2 NFS"></a>3.2 NFS</h3><h4 id="3-2-1-NFS简介"><a href="#3-2-1-NFS简介" class="headerlink" title="3.2.1 NFS简介"></a>3.2.1 NFS简介</h4><ul>
<li>NFS（NetworkFileSystem）即网络文件系统，允许计算机在远程计算机上像挂载本地分区一样挂载磁盘分区。它允许在网络上快速、无缝地共享文件<br><img src="/file-20250510154538894.png"></li>
<li>在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样</li>
<li>NFS适用于Linux与Unix之间实现文件共享，不能实现Linux与Windows间的文件共享功能</li>
<li>NFS服务只能基于IP进行认证</li>
</ul>
<h4 id="3-2-2-NFS服务所需软件"><a href="#3-2-2-NFS服务所需软件" class="headerlink" title="3.2.2 NFS服务所需软件"></a>3.2.2 NFS服务所需软件</h4><ul>
<li><p>RPC主程序:<code>rpcbind</code></p>
</li>
<li><p>RPC主程序负责NFS的端口映射工作，<strong>监听在111端口</strong>，程序名为<code>portmaper</code>，可通过<code>rpcinfo</code>命令查看端口映射情况，如：<code>rpcinfo -p localhost</code></p>
</li>
<li><p>NFS主程序：<code>nfs-utils</code></p>
</li>
<li><p>NFS主程序，提供<code>rpc.nfsd</code>及<code>rpc.mountd</code>，以及其他相关的documents与说明文件、执行文件等的软件，是NFS服务所需要的主要软件</p>
</li>
<li><p><code>rpcbind</code>可以将RPC程序号码和通用地址进行转换。要让某个主机能够远程主机的服务发起RPC调用，那么该主机上的<code>rpcbind</code>必须处于运行状态。<code>Rpcbind</code>需要在所有RPC管理服务（rpc service）启动之前启动</p>
</li>
<li><p>使用<code>yum install nfs-utils</code>时，将自动安装<code>rpcbind</code>，<code>nfs-utils</code>依赖<code>rpcbind</code>进程</p>
</li>
<li><p><code>RPC（Remote Procedure Call）</code>远程过程调用，它是一种通过网络从远程计算机程序上请求服务，<strong>不需要了解底层网络技术的协议</strong>。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，<strong>RPC跨越了传输层和应用层</strong></p>
</li>
<li><p>RPC采用客户机&#x2F;服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行</p>
</li>
<li><p><code>portmapper</code>（也称为<code>portmap</code>）当一个RPC服务启动时，会选择一个<strong>空闲的端口号</strong>并在上面监听（每次启动后的端口号各不相同），同时它作为一个可用的服务在portmap中进行注册。一个PRC服务对应唯一一个RPC程序号，RPC服务器告诉portmap进程它在哪个端口号上监听链接请求和为哪个RPC程序提供服务。Portmap进程一般使用TCP&#x2F;UDP的111端口</p>
</li>
<li><p>nfsd：服务器端用户级别的过程，将请求重定向到内核传输端点，并调用内核内进程来处理请求并响应客户端</p>
</li>
</ul>
<h4 id="3-2-3-NFS工作机制"><a href="#3-2-3-NFS工作机制" class="headerlink" title="3.2.3 NFS工作机制"></a>3.2.3 NFS工作机制</h4><ul>
<li>NFS服务器端启动及建立传输的过程<ul>
<li>服务器端先启动RPC服务，再启动NFS进程，并向RPC注册端口信息</li>
<li>客户端启动RPC服务（portmap服务），向服务器端RPC（protmap）请求服务端的NFS端口</li>
<li>服务器端RPC服务反馈NFS端口信息给客户端</li>
<li>客户端通过获取的NFS端口来建立和服务器端NFS的连接并进行数据的传输</li>
</ul>
</li>
<li>NFS用户建立传输及数据存取过程<ul>
<li>用户访问网站程序，由程序在NFS客户端发出存取NFS文件的请求，NFS客户端上的RPC服务通过网络向NFS服务器的RPC服务的111端口发出NFS文件存取的询问请求</li>
<li>NFS服务器的RPC找到对应已注册的NFS端口后，通知NFS客户端的RPC服务</li>
<li>NFS客户端获取正确的端口，并与NFSdaemon联机存取数据</li>
<li>NFS客户端把数据存取成功后，返回给前端访问程序，告知用户存取结果，作为网站用户，就完成了一次存取操作<br><img src="/file-20250510161311569.png"></li>
</ul>
</li>
</ul>
<h4 id="3-2-4-NFS服务器安装"><a href="#3-2-4-NFS服务器安装" class="headerlink" title="3.2.4 NFS服务器安装"></a>3.2.4 NFS服务器安装</h4><ul>
<li>检查服务端是否安装了nfs<ul>
<li><code>rpm -aq |grep nfs</code></li>
</ul>
</li>
<li>检查服务端是否安装了rpcbind<ul>
<li><code>rpm -aq |grep rpcbind </code></li>
</ul>
</li>
<li>安装nfs<ul>
<li><code>yum install nfs-utils</code></li>
</ul>
</li>
<li>设置开机自启动nfs服务&amp;rpcbind服务<ul>
<li><code>systemctl enable nfs --now</code></li>
</ul>
</li>
</ul>
<h4 id="3-2-5-NFS服务器配置"><a href="#3-2-5-NFS服务器配置" class="headerlink" title="3.2.5 NFS服务器配置"></a>3.2.5 NFS服务器配置</h4><ul>
<li>创建共享目录 <code>mkdir /XX/</code></li>
<li>编辑配置文件 <code>vi /etc/exports</code><ul>
<li>增加一行内容：<code>/XX/ *(rw,sync)</code></li>
</ul>
</li>
<li>重启nfs服务 <code>systemctl restart nfs</code></li>
<li>检查是否存在共享目录 <code>showmount -e</code></li>
</ul>
<p><img src="/file-20250510162057873.png"></p>
<ul>
<li>&#x2F;XX&#x2F;表示服务端共享的目录</li>
<li><code>*</code> 指允许所有ip的机器访问共享目录</li>
<li>如果是指定客户端IP，则只允许该客户端ip主机访问</li>
<li><code>*</code>或IP地址与（）之间不能有空格</li>
<li><code>anonuid</code>：将登入NFS主机的用户都设定成指定的user id，此ID必须存在于&#x2F;etc&#x2F;passwd中</li>
<li><code>anongid</code>：同anonuid，变成group ID</li>
</ul>
<h4 id="3-2-6-NFS客户端配置"><a href="#3-2-6-NFS客户端配置" class="headerlink" title="3.2.6 NFS客户端配置"></a>3.2.6 NFS客户端配置</h4><ul>
<li><p>检查挂载点</p>
<ul>
<li><code>showmount -e 服务端IP地址</code></li>
</ul>
</li>
<li><p>挂载远程目录</p>
<ul>
<li><code>mount -t nfs 服务端IP地址:/XX/ /mnt/app/test</code></li>
</ul>
</li>
<li><p>检查是否挂载成功</p>
<ul>
<li><code>df -h</code></li>
</ul>
</li>
<li><p>开机自动挂载，编写&#x2F;etc&#x2F;fstab</p>
<ul>
<li><code>服务端IP地址:/xx/ 挂载目录 nfs defaults,_netdav 0 0</code></li>
</ul>
</li>
<li><p>&#x2F;XX&#x2F;为远程共享目录，与ip地址之间用“:”隔开</p>
</li>
<li><p>&#x2F;mnt&#x2F;app&#x2F;test&#x2F;为客户端挂载点</p>
</li>
<li><p>mount –t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态</p>
</li>
<li><p>-t nfs代表的是指明挂载的文件系统类型</p>
</li>
<li><p>自动挂载格式：要挂载的设备或伪文件系统 挂载点 文件系统类型 挂载选项 转储<br>频率 自检次序</p>
</li>
<li><p>NFS自动挂载参数：</p>
<ul>
<li>要挂载的设备为：</li>
<li>服务端IP地址:&#x2F;xx&#x2F;</li>
<li>挂载点为：&#x2F;mnt&#x2F;app&#x2F;test</li>
<li>文件系统类型为： nfs</li>
<li>挂载选项为：defaults</li>
<li>转储频率： 0不做备份；1每天转储；2每隔一天转储</li>
<li>自检次序：0不自检；1首先自检，一般只有rootfs才使用1</li>
</ul>
</li>
</ul>
<h3 id="3-3-存储区域网络SAN"><a href="#3-3-存储区域网络SAN" class="headerlink" title="3.3 存储区域网络SAN"></a>3.3 存储区域网络SAN</h3><h4 id="3-3-1-SAN简介"><a href="#3-3-1-SAN简介" class="headerlink" title="3.3.1 SAN简介"></a>3.3.1 SAN简介</h4><ul>
<li>SAN存储（StorageAreaNetwork）是一种专门设计用于数据存储的网络体系结构，它将大量的存储设备（磁盘阵列、磁带库、光盘库等）连接起来，并提供高效的数据访问和管理服务<br><img src="/file-20250510163000947.png"></li>
</ul>
<p>SAN的架构通常是由以下几个部分组成：</p>
<ul>
<li>存储设备：存储设备通常包括磁盘阵列、磁带库、光盘库等等。这些设备通过光纤通道连接到存储交换机上，提供高速数据传输和存储</li>
<li>存储交换机：存储交换机是SAN存储网络的核心，它负责将存储设备和主机之间的数据传输进行管理和调度</li>
<li>存储交换机通常使用光纤通道协议（Fiber Channel）进行通信</li>
<li>主机：主机是指访问存储设备的计算机系统，它们连接到存储交换机上，并通过SAN存储网络访问存储设备中的数据<br>SAN存储的优点包括高速传输、高可靠性、易于管理和扩展等，因此被广泛应用于企业数据存储、虚拟化等领域</li>
</ul>
<h4 id="3-3-2-iSCSI"><a href="#3-3-2-iSCSI" class="headerlink" title="3.3.2 iSCSI"></a>3.3.2 iSCSI</h4><h5 id="3-3-2-1-iSCSI简介"><a href="#3-3-2-1-iSCSI简介" class="headerlink" title="3.3.2.1 iSCSI简介"></a>3.3.2.1 iSCSI简介</h5><ul>
<li>iSCSI（小型计算机系统接口）是用于计算机和智能设备之间系统级接口的独立处理器标准。</li>
<li>iSCSI是基于IP协议的技术标准，该技术允许用户通过TCP&#x2F;IP网络来构建SAN</li>
<li><img src="/file-20250510164237590.png"></li>
<li>iSCSI可以实现在IP网络上运行SCSI协议，使其能够在诸如高速千兆以太网上进行路由选择，实现了SCSI和TCP&#x2F;IP协议的连接</li>
<li>iSCSI：用于在基于IP的存储设备之间建立连接及管理连接，在现有的IP网络上封装SCSI数据进行传输</li>
</ul>
<h5 id="3-3-2-2-iSCSI的基本组成"><a href="#3-3-2-2-iSCSI的基本组成" class="headerlink" title="3.3.2.2 iSCSI的基本组成"></a>3.3.2.2 iSCSI的基本组成</h5><ul>
<li><p>iSCSI会话的建立是通过启动器（Initiator）和目标器（Target）实现的</p>
</li>
<li><p>Target为服务端，是一个或多个存储设备（LUN）的集合</p>
</li>
<li><p>Initiator则是客户端使用的工具，用来连接target</p>
</li>
<li><p>Target和initiator都使用IQN来识别<br><img src="/file-20250510164413119.png"></p>
</li>
<li><p>Target端即磁盘阵列或其他装有磁盘的主机，是一个或多个存储设备（LUN）的集合，由服务器端创建。iscsi在target端工作在套接字上，监听端口默认是3260，使用tcp协议保证数据安全</p>
</li>
<li><p>而initiator则是客户端使用的工具，用来连接服务器端创建的target，通过iscsi target工具将磁盘空间映射到网络上，initiator端就可以寻找发现并使用该磁盘。</p>
</li>
<li><p>iscsi对客户端有身份认证的需求，有两种认证方式：基于IP认证，基于CHAP认证（双向认证）</p>
</li>
</ul>
<h5 id="3-3-2-3-IQN简介"><a href="#3-3-2-3-IQN简介" class="headerlink" title="3.3.2.3 IQN简介"></a>3.3.2.3 IQN简介</h5><ul>
<li><p>IQN的全称为iSCSIQualified Name，用来识别iSCSI设备</p>
</li>
<li><p>IQN命名格式为:<code>iqn.yyyy-mm.&lt;reversed domain name&gt;[:identifier]</code></p>
<ul>
<li>yyyy-mm表示“年-月”</li>
<li>reversed domain name表示倒过来的域名，全局唯一</li>
<li>identifier是识别名称，可选</li>
</ul>
</li>
<li><p>在openEuler中，initiator的IQN相关配置存放<code>/etc/iscsi/initiatorname.iscsi</code>中</p>
</li>
<li><p>iqn全称ISCSI Qualified Name，它是target的唯一标识符，客户端正是通过这个标识符找到target的。IQN有一个命名标准，例如：<code>iqn.20XX-XX.com.example:storage1</code></p>
</li>
<li><p>反过来的域名例如：test.com 写作com.test</p>
</li>
</ul>
<h4 id="3-3-3-基于Linux的SAN配置流程"><a href="#3-3-3-基于Linux的SAN配置流程" class="headerlink" title="3.3.3 基于Linux的SAN配置流程"></a>3.3.3 基于Linux的SAN配置流程</h4><p>Target配置</p>
<ul>
<li><p>安装target</p>
</li>
<li><p>创建target</p>
</li>
<li><p>为target添加LUN</p>
</li>
<li><p>指定Initiator<br>Initiator配置</p>
</li>
<li><p>安装Initiator</p>
</li>
<li><p>发现target</p>
</li>
<li><p>连接target</p>
</li>
<li><p>分区、格式化</p>
</li>
<li><p>优先配置服务端target后才可以在客户端进行发现</p>
</li>
<li><p>安装target端：  <code>yum install –y scsi-target-utils</code></p>
</li>
<li><p>安装initiator端：<code>yum -y install iscsi-initiator-utils</code></p>
</li>
</ul>
<h5 id="3-3-3-1-Target配置方法"><a href="#3-3-3-1-Target配置方法" class="headerlink" title="3.3.3.1 Target配置方法"></a>3.3.3.1 Target配置方法</h5><p>命令行配置</p>
<ul>
<li>Targetcli:由最新的target管理工具LIO（Linux-lOTarget）提供，运行在在用户态，为用户提供了友好的操作界面</li>
<li>Tgtadm：LIO前最受欢迎的target工具，提供了LUN、ACL等的管理功能，还提供了对已连接上的initiator的检测和iSNS服务的支持</li>
<li>letadm:依赖内核模块iscsi_trgt.ko来帮助iSCSl设备的创建<br>修改配置文件</li>
<li>Tgtadm命令无法保存配置，需要将当前配置保存到配置文件中，供系统下次启动时加载</li>
</ul>
<h6 id="3-3-3-1-1-Tgtadm简介"><a href="#3-3-3-1-1-Tgtadm简介" class="headerlink" title="3.3.3.1.1 Tgtadm简介"></a>3.3.3.1.1 Tgtadm简介</h6><ul>
<li><p>Tgtadm用于target的l临时配置，重启target服务后，配置失效</p>
</li>
<li><p>Tgtadm的语法格式为: <code>tgtadm --lld [driver] --op [operation] --mode [mode][OPTION]...</code></p>
</li>
<li><p>Tagadm常用选项包括：</p>
<ul>
<li>Driver驱动程序<ul>
<li>iscsi</li>
</ul>
</li>
<li>Mode 操作对象<ul>
<li>target</li>
<li>logicalunit</li>
<li>account</li>
</ul>
</li>
<li>OPTION操作<ul>
<li>delete</li>
<li>new</li>
<li>bind&amp; unbind</li>
<li>show</li>
</ul>
</li>
</ul>
</li>
<li><p>target：iSCSI Target是一个虚拟的存储设备，可以被多个iSCSI Initiator访问</p>
</li>
<li><p>logicalunit：是iSCSI Target上的一个逻辑存储单元，可以被iSCSI Initiator看作是一个独立的存储设备</p>
</li>
<li><p>account：Account是iSCSI Target上的一个用户账户，用于授权iSCSI Initiator访问Target或Logical Unit</p>
</li>
</ul>
<h6 id="3-3-3-1-2-Tgtadm常用参数"><a href="#3-3-3-1-2-Tgtadm常用参数" class="headerlink" title="3.3.3.1.2 Tgtadm常用参数"></a>3.3.3.1.2 Tgtadm常用参数</h6><p><img src="/file-20250510165228253.png"></p>
<p>iSER 代表“用于 RDMA 的 iSCSI 扩展”（iSCSI Extensions for RDMA)。它是 iSCSI数据传输模型的扩展，iSCSI 是 TCP&#x2F;IP 的存储网络标准。iSER在利用 iSCSI 组件的同时使用RDMA 协议套件</p>
<h6 id="3-3-3-1-3-Target永久配置-编辑配置文件"><a href="#3-3-3-1-3-Target永久配置-编辑配置文件" class="headerlink" title="3.3.3.1.3 Target永久配置 - 编辑配置文件"></a>3.3.3.1.3 Target永久配置 - 编辑配置文件</h6><ul>
<li>使用命令 <code>tgt-admin --dump</code>可查看到当前配置，将输出信息复制到配置文件中</li>
<li>编辑配置文件<code>/etc/tgt/targets.conf</code>，增加如下命令行：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;target iqn.2018-09.com.example:target1&gt;</span><br><span class="line">	backing-store                 /dev/vdb1       #指定已划分的分区</span><br><span class="line">	initiator-address             192.168.1.11    #客户端访问控制</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-3-3-2-Target配置案例"><a href="#3-3-3-2-Target配置案例" class="headerlink" title="3.3.3.2 Target配置案例"></a>3.3.3.2 Target配置案例</h5><p>需求：在SAN存储中创建一个名为<code>iqn.2023.04.com.openeuler:target1</code>的target，tid设置<br>为1，并为该target添加LUN <code>/dev/vdb</code>，允许地址192.168.1.1访问<br>配置过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@web</span> ~]# yum -y install scsi-target-utils</span><br><span class="line">[root<span class="meta">@web</span>~]# tgtadm--lld iscsi--mode target--op <span class="keyword">new</span>--tid <span class="number">1</span> --targetname iqn<span class="number">.2023</span>-<span class="number">04.</span>com.openeuler:target1</span><br><span class="line">[root<span class="meta">@web</span> ~]# tgtadm--lld iscsi --mode logicalunit-op <span class="keyword">new</span>-tid <span class="number">1</span>--lun <span class="number">1</span> --backing-store /dev/vdb</span><br><span class="line">[root<span class="meta">@web</span>~]# tgtadm--ld iscsi --mode target--op bind--tid <span class="number">1</span> --initiator-address <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">[root<span class="meta">@web</span> ~]# tgt-admin--dump</span><br><span class="line"><span class="keyword">default</span>-driver iscsi</span><br><span class="line">&lt;target iqn<span class="number">.2023</span>-<span class="number">04.</span>com.openeuler:target1&gt;</span><br><span class="line">backing-store /dev/sdb</span><br><span class="line">initiator-address <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">&lt;/target&gt;</span><br><span class="line">[root<span class="meta">@web</span> ~]# tgt-admin --dump I grep -A <span class="number">4</span> target &gt;&gt; /etc/tgt/targets.conf</span><br></pre></td></tr></table></figure>


<h2 id="0x04-分布式存储介绍"><a href="#0x04-分布式存储介绍" class="headerlink" title="0x04 分布式存储介绍"></a>0x04 分布式存储介绍</h2><h3 id="4-1-常见的分布式存储架构"><a href="#4-1-常见的分布式存储架构" class="headerlink" title="4.1 常见的分布式存储架构"></a>4.1 常见的分布式存储架构</h3><ul>
<li><p>HDFS</p>
<ul>
<li>Hadoop核心组成之一，是分布式计算数据存储管理的基础，被设计成适合运行在通用硬件上的分布式文件系统</li>
</ul>
</li>
<li><p>Swift</p>
<ul>
<li>最初由Rackspace公司开发的分布式对象存储服务，2010年共享给OpenStack开源社区</li>
</ul>
</li>
<li><p>Ceph</p>
<ul>
<li>统一存储，支持块存储、对象存储和文件存储</li>
<li>起源于Sage就读博士工作期间的工作，成果发表于2004年，并随后共享给了开源社区</li>
</ul>
</li>
<li><p>Glusterfs</p>
<ul>
<li>GlusterFS是一个开源的分布式文件系统，允许将多个服务器上的存储资源组合成一个虚拟文件系统，以提供更高的可靠性、可扩展性、性能和容错能力</li>
</ul>
</li>
<li><p>HDFS：中间控制节点架构</p>
<ul>
<li>Client：用户与HDFS交互的客户端，切割上传文件为多个Block，与NameNode交互获取文件信息，与DataNode交互读写数据</li>
<li>NameNode：HDFS的Master，维护文件系统树，及整棵树内所有文件和目录</li>
<li>DataNode：执行实际操作，表示实际存储的数据块</li>
<li>Scondary NameNode： 辅助NameNode工作</li>
</ul>
</li>
<li><p>Swift：完全无中心架构–一致性哈希</p>
<ul>
<li>完全对称、面向资源的分布式架构，组件可扩展，避免单点故障</li>
</ul>
</li>
<li><p>Ceph：完全无中心架构—计算模式</p>
<ul>
<li>基础存储系统RADOS，实现高可靠、高扩展等功能，并存储用户数据，有CephOSD和Ceph Monitors组成</li>
<li>基础库LIBRADOS，对RADOS进行抽象和封装，并向上层提供API</li>
<li>上层应用接口，涵盖RADOSGW（RADOS Gateway）、RBD（Reliable Block Device）和Ceph FS（Ceph File System）</li>
<li>应用层，不同场景下对Ceph各个应用的接口的应用</li>
</ul>
</li>
<li><p>Ceph的功能模块：</p>
</li>
<li><p>Client客户端：负责存储协议的接入，节点负载均衡</p>
</li>
<li><p>MON监控服务：负责监控整个集群，维护集群的健康状态，维护展示集群状态的各种图表，如OSD Map、Monitor Map、PG Map和CRUSH Map</p>
</li>
<li><p>MDS元数据服务：负责保存文件系统的元数据，管理目录结构</p>
</li>
<li><p>OSD存储服务：主要功能是存储数据、复制数据、平衡数据、恢复数据，以及与其它OSD间进行心跳检查等。一般情况下一块硬盘对应一个OSD</p>
</li>
</ul>
<p>其他分布式存储：</p>
<ul>
<li>Lustre一个开源、可扩展的高性能面向对象的并行文件系统，被广泛应用于超级计算平台HPC</li>
</ul>
<h3 id="4-2-GlusterFS的优点"><a href="#4-2-GlusterFS的优点" class="headerlink" title="4.2 GlusterFS的优点"></a>4.2 GlusterFS的优点</h3><ul>
<li>支持扩展到PB级别的存储</li>
<li>支持处理成千上万的客户端</li>
<li>兼容POSIX标准</li>
<li>使用通用硬件</li>
<li>开源产品</li>
<li>支持使用任何支持扩展属性的磁盘文件系统</li>
<li>支持使用行业标准协议进行访问，如：NFS、SMB</li>
<li>支持优化不同的工作负载</li>
</ul>
<h3 id="4-3-GlusterFS分布式存储功能特点"><a href="#4-3-GlusterFS分布式存储功能特点" class="headerlink" title="4.3 GlusterFS分布式存储功能特点"></a>4.3 GlusterFS分布式存储功能特点</h3><ul>
<li><p>高可用性：GlusterFs能够自动检测存储节点的故障，并将数据转移到其他节点上，保证数据的高可用性。</p>
</li>
<li><p>负载均衡：GlusterFS采用分布式存储方式，能够自动将数据均匀地分散在不同的存储节点上，有效地实现负载均衡</p>
</li>
<li><p>可扩展性：GluserFS的Scale-Out架构可以实现随着存储需求的增加，添加更多的存储节点，以增加存储容量。</p>
</li>
<li><p>数据安全：GlusterFS采用数据冗余的方式，将数据复制到多个存储节点上，以保证数据的安全性</p>
</li>
<li><p>高性能：GlusterFS的弹性哈希算法能够实现快速读写，支持多个客户端并发访问，提高系统的性能</p>
</li>
<li><p>易于管理：GlusterFS提供了一套完整的管理工具，使得系统管理员可以轻松地管理存储节点和文件系统</p>
</li>
<li><p>GlusterFS弹性哈希解决了GlusterFS对元数据服务器的依赖，改善了单点故障和性能瓶颈，真正实现了并行化数据访问</p>
<ul>
<li>弹性HASH算法是Davis-Meyer算法的具体实现，通过HASH算法可以得到一个32位的证书范围的hash值</li>
<li>假设逻辑卷中有N个存储单位Brick，则32位的整数发文将被划分N个连续的子空间，每个空间对应一个rick</li>
<li>当用户或应用程序访问某一个命名空间时，通过对该命名空间计算HASH值，根据该 HASH 值所对应的 32 位整数空间定位数据所在的Brick</li>
</ul>
</li>
<li><p>GlusterFS可以支持所有的存储，它没有自制的私有数据文件格式，采用操作系统中主流标准的磁盘文件系统（如EXT3、XFS等）来存储文件。Gluster存储服务支持NFS、CIFS、HTTP、FTP、SMB及Gluster原生协议，完全与POSIX标准（可移植操作系统接口）兼容</p>
</li>
</ul>
<h3 id="4-4-GlusterFS架构"><a href="#4-4-GlusterFS架构" class="headerlink" title="4.4 GlusterFS架构"></a>4.4 GlusterFS架构</h3><ul>
<li>Brick：存储块<ul>
<li>GlusterFS的基本存储单元，一个独立的数据存储单元，可信存储池中服务器上对外提供的存储目录</li>
</ul>
</li>
<li>Volume：逻辑卷<ul>
<li>一组Brick的集合，大部分的Gluster管理操作是在卷上进行的</li>
</ul>
</li>
<li>FUSE：<ul>
<li>一个内核模块，允许用户创建自己的文件系统，无需修改该内核代码</li>
</ul>
</li>
<li>VFS：<ul>
<li>内核空间对用户提供的访问磁盘的接口</li>
</ul>
</li>
<li>Glusterd：后台管理进程<ul>
<li>在存储集群中的每个节点上运行的管理进程<br><img src="/assets/03%20openEuler%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/file-20250519020610026.png"><br>图片来源：<a target="_blank" rel="noopener" href="https://docs.gluster.org/en/latest/Quick-Start-Guide/Architecture/">https://docs.gluster.org/en/latest/Quick-Start-Guide/Architecture/</a></li>
</ul>
</li>
</ul>
<h3 id="4-4-GlusterFS常见卷模式介绍"><a href="#4-4-GlusterFS常见卷模式介绍" class="headerlink" title="4.4 GlusterFS常见卷模式介绍"></a>4.4 GlusterFS常见卷模式介绍</h3><ul>
<li><p>Distribute   分布式卷</p>
</li>
<li><p>Replicated   复制卷</p>
</li>
<li><p>Distribute Replication  分布复制卷</p>
</li>
<li><p>Dispersed    分散卷</p>
</li>
<li><p>Distribute Dispersed    分布式分散卷</p>
</li>
<li><p>GlusterFS支持7种卷类型</p>
<ul>
<li>分布式卷：文件通过哈希算法分不到所有Brick Server上，为默认卷类型，未对文件进行分块处理，文件直接存储在某个Server节点上，属于文件级别RAID0</li>
<li>分散卷：（纠删卷&#x2F;分散冗余卷）文件被分成数据块并以轮询的方式分布到多个Brick Server上，问价存储以数据块为单位，不具备冗余，类似RAID5&#x2F;6</li>
<li>复制卷：将文件同步到多个Brick Server上，具备多个副本，属于RAID1</li>
<li>分布式分散卷：Brick Server数量为条带数的倍数，创建一个分布式条带卷至少需要4台服务器，类似RAID50</li>
<li>分布式复制卷：Brick Server数量为镜像数的倍数，用于冗余场景，类似RAIDI10</li>
</ul>
</li>
</ul>
<h4 id="4-4-1-分布式卷-Distributed-Glusterfs-Volume"><a href="#4-4-1-分布式卷-Distributed-Glusterfs-Volume" class="headerlink" title="4.4.1 分布式卷 Distributed Glusterfs Volume"></a>4.4.1 分布式卷 Distributed Glusterfs Volume</h4><ul>
<li>文件分布在卷中的各个块上。因此，File1可能只存储在Brick 1或Brick 2中，但不能同时存储在这两个中。分布式卷没有数据冗余</li>
<li><img src="/assets/03%20openEuler%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/file-20250519030317623.png"></li>
<li>此类存储卷的目的是轻松且便宜地扩展卷大小。然而，这也意味着砖块故障将导致数据完全丢失，必须依靠底层硬件来保护数据丢失</li>
<li>File1和File2存放在Server1，而File3存放在Server2，文件都是随机存储，一个文件（如File1）要么在Server1上，要么在Server2上，不能分块同时存放在Server1和Server2上</li>
<li>适用场景：适合存储非关键数据，如日志、缓存等</li>
<li>创建一个名为dis-volume的分布式卷，文件将根据HASH分布在server1:&#x2F;exp1、server2:&#x2F;exp2和server3:&#x2F;exp3中</li>
<li>gluster volume create dis-volume server1:&#x2F;esp1 server2:&#x2F;exp2 server3:&#x2F;exp3</li>
<li>图片链接：Architecture - Gluster Docs，以下４页出处相同</li>
</ul>
<h4 id="4-4-2-复制卷-Replicated-Glusterfs-Volume"><a href="#4-4-2-复制卷-Replicated-Glusterfs-Volume" class="headerlink" title="4.4.2 复制卷 Replicated Glusterfs Volume"></a>4.4.2 复制卷 Replicated Glusterfs Volume</h4><ul>
<li>复制卷中为数据创建冗余，数据的副本将保存在所有Brick上。卷中的副本数量可以有客户端在创建卷时决定。提高可靠性和数据冗余</li>
<li><img src="/assets/03%20openEuler%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/file-20250519030524486.png"></li>
<li>适用场景：适合存储关键数据，如数据库、文件系统等</li>
<li>File1 同时存在 Server1 和 Server2，File2 也是如此，相当于 Server2 中的文件是Server1 中文件的副本。</li>
<li>需要至少有两个Brick来创建一个包含2个副本的卷，或者至少三个Brick来创建一个包含3个副本的卷。</li>
<li>卷中所有服务器均保存一个完整的副本，具备冗余性</li>
<li>卷的副本数量可自定义，单复制数必须等于卷中Brick所包含的存储服务器数量</li>
<li>至少有两个以上服务器，2个副本的情况下，发生脑裂的几率较大，建议至少3副本部署。</li>
<li>若多个节点上的存储空间不一致，按木桶效应取最低节点的容量作为改卷的总容量</li>
</ul>
<h4 id="4-4-3-分布式复制卷-Distributed-Replicated-Glusterfs-Volume"><a href="#4-4-3-分布式复制卷-Distributed-Replicated-Glusterfs-Volume" class="headerlink" title="4.4.3 分布式复制卷 Distributed Replicated Glusterfs Volume"></a>4.4.3 分布式复制卷 Distributed Replicated Glusterfs Volume</h4><ul>
<li>文件分布在复制的Brick集上。Brick的数量必须是副本数量的倍数。此外我们指定Brick的顺序也很重要，因为相邻的Brick将成为彼此的副本</li>
<li><img src="/assets/03%20openEuler%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/file-20250519030858914.png"></li>
<li>如果有8个Brick，副本数为2，那么前两块Brick将成为彼此的副本，然后是下两块Brick，依此类推。此卷表示为4x2。类似地，如果有8个Brick，副本计数为4，则4个Brick将成为彼此的副本，我们将此卷表示为2x4卷</li>
<li>File1 和 File2 通过分布式卷的功能分别定位到 Server1 和 Server3。在存放 File1 时，File1 根据复制卷的特性，将存在两个相同的副本，分别是 Server1 中的exp1 目录和Server2 中的 exp2 目录。在存放 File2 时，File2 根据复制卷的特性，也将存在两个相同的副本，分别是 Server3 中的 exp3 目录和 Server4 中的 exp4 目录</li>
<li>适用场景：适合存储关键数据，如数据库、文件系统等，同时需要提高数据读写性能</li>
</ul>
<h4 id="4-4-4-分散卷-Dispersed-Glusterfs-Volume"><a href="#4-4-4-分散卷-Dispersed-Glusterfs-Volume" class="headerlink" title="4.4.4 分散卷 Dispersed Glusterfs Volume"></a>4.4.4 分散卷 Dispersed Glusterfs Volume</h4><ul>
<li>分散卷基于纠删码。它将文件的编码数据条带化，并添加了一些冗余，跨卷中的多个Brick存储。分散冗余卷具有高可靠性，并且将不浪费空间。卷中的冗余Brick数量可以与客户端在创建卷时设置</li>
<li><img src="/assets/03%20openEuler%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/file-20250519031125749.png"></li>
<li>冗余Brick的数量保证不中断卷操作的情况下可以丢失多少个Brick</li>
<li>分散卷也被成为纠删卷&#x2F;分散冗余卷</li>
<li>纠删卷适用于需要高可用性和数据保护的场景，如存储重要数据、数据库、虚拟机镜像等</li>
<li>File 1有10MB大小，被分为2段数据，同时使用纠删码技术对数据块进行编码，将原始数据块编码为3个编码块，编码块被分散存储在不同的物理节点上，分别在Server1、Server2、Server3中，当需要读取数据时，Dispersed Volume从存储数据的各个节点上获取编码块。然后，它使用纠删码技术将编码块解码成原始数据块，并将它们组合起来返回给用户。File 2使用同样方法进行存储</li>
</ul>
<h4 id="4-4-5-分布式分散卷Distributed-Dispersed-Glusterfs-Volume"><a href="#4-4-5-分布式分散卷Distributed-Dispersed-Glusterfs-Volume" class="headerlink" title="4.4.5 分布式分散卷Distributed Dispersed Glusterfs Volume"></a>4.4.5 分布式分散卷Distributed Dispersed Glusterfs Volume</h4><ul>
<li>分布式分散卷相当于分布式复制卷，但使用分散的子卷而不是复制的子卷。Brick的数量必须是第一个子卷的倍数。目的是轻松地缩放卷大小，并在不同的Brick之间分配负载</li>
<li><img src="/assets/03%20openEuler%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/file-20250519031232645.png"></li>
<li>纠删卷和分布式纠删卷都适用于需要高可用性和数据保护的场景，但分布式纠删卷更适合大规模数据存储和高性能应用</li>
</ul>
<h3 id="4-5-安装部署GlusterFS"><a href="#4-5-安装部署GlusterFS" class="headerlink" title="4.5 安装部署GlusterFS"></a>4.5 安装部署GlusterFS</h3><h4 id="4-5-1-流程"><a href="#4-5-1-流程" class="headerlink" title="4.5.1 流程"></a>4.5.1 流程</h4><ul>
<li>服务器端<ul>
<li>准备至少三台node节点</li>
<li>格式化和挂载bricks</li>
<li>安装glusterfs-server</li>
<li>配置防火墙</li>
<li>配置trusted pool</li>
<li>创建并启用GlusterFS卷</li>
</ul>
</li>
<li>客户端<ul>
<li>配置防火墙</li>
<li>安装客户端软件</li>
<li>添加node主机名解析配置</li>
<li>挂载GlusterFS卷</li>
</ul>
</li>
</ul>
<h4 id="4-5-2-格式化和挂载bricks"><a href="#4-5-2-格式化和挂载bricks" class="headerlink" title="4.5.2 格式化和挂载bricks"></a>4.5.2 格式化和挂载bricks</h4><ul>
<li>所有的节点都需执行格式化和挂载bricks</li>
<li>属于同一个卷的bricks的容量建议配置一致，如果不一致则取其中最小值</li>
<li>Bricks可以是任意文件系统的目录</li>
<li>具体配置如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfs.xfs -i size=512 /dev/sdb1     ####创建分区sdb1</span><br><span class="line">mkdir -p /data/brick1              ####创建一个目录，将其作为其中一个brick</span><br><span class="line">echo &#x27;/dev/sdb1 /data/brick1 xfs defaults 1 2&#x27; &gt;&gt; /etc/fstab                 ####降分sdb1设置为开机自动挂载给brick</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-5-3-卷创建"><a href="#4-5-3-卷创建" class="headerlink" title="4.5.3 卷创建"></a>4.5.3 卷创建</h4><ul>
<li><p>GlusterFS卷创建命令格式为：</p>
<ul>
<li>分布式卷: <code>gluster volume create &lt;volume-name&gt; [transport [tcp | rdma| tcp,rdma]] brick1,brick2...</code></li>
</ul>
</li>
<li><p>复制卷: <code>gluster volume create &lt;volume-name&gt; [replica COuNT] [transport [tcp Irdma tcp,rdmal]] brick1,brick2...</code></p>
</li>
<li><p>分布式复制卷:<code>gluster volume create &lt;volume-name&gt; [replica COUNT] [transport [tcp rdma | tcp,rdma]] brick1,brick-2...</code></p>
</li>
<li><p>分散卷: <code>gluster volume create &lt;volume-name&gt; [disperse [&lt;COUNT&gt;]][disperse-data &lt;COUNT&gt;] [redundancy &lt;COUNT&gt;] [transport tcp | rdma | tcp,rdma] brick1,brick2...</code></p>
</li>
<li><p>分布式分散卷:<code>gluster volume create &lt;volume-name&gt; [disperse [&lt;COUNT&gt;]] [disperse-data &lt;COUNT&gt;] [redundancy &lt;COUNT&gt;] [transport tcp | rdma | tcp,rdma]brick1,brick2...</code></p>
</li>
<li><p>卷创建命令中的选项说明：</p>
<ul>
<li>volume-name:卷名字</li>
<li>Transport:传输方式，支持tcp、rdma、tcp,rdma</li>
<li>COUNT:数量</li>
<li>brick1,brick2.:用于组成卷的brick块，可添加多个用空格隔开，格式为nodeX:&#x2F;XX</li>
<li>disperse-data：分散卷中每个文件增加纠删码之前需要分片</li>
<li>disperse：分散卷中每个文件最终分片，文件需要被分散到多少个Brick中</li>
<li>redundancy：冗余片，分散卷中需要增加了纠删码后多出来的分片</li>
</ul>
</li>
</ul>
<h4 id="4-5-4-配置防火墙及trusted-pool"><a href="#4-5-4-配置防火墙及trusted-pool" class="headerlink" title="4.5.4 配置防火墙及trusted pool"></a>4.5.4 配置防火墙及trusted pool</h4><ul>
<li><p>防火墙配置：</p>
<ul>
<li><code>iptables -I INPUT -p all -s &lt;other-ip-address&gt; -j ACCEPT</code></li>
</ul>
</li>
<li><p>Trusted pool配置：</p>
<ul>
<li>信任池（Trustedpool）是由所有GlusterFS服务节点（TSP甚至可以包含单个节点）组成的可信服务器池(TSP)。</li>
<li>添加某节点进入信任池（当前节点无需加入）：<code>gluster peer probe nodeX</code></li>
<li>查看信任池状态：<code>gluster peer status</code></li>
</ul>
</li>
<li><p>每个节点上的Gluster进程需要相互访问、相互通信，可以在每个节点上配置端口全部对其他节点开放（保证网络安全的前提下）</p>
</li>
<li><p>信任池中的任意数量的磁盘块可以被连接在一起形成一个大的存储卷</p>
</li>
<li><p>建立信任池后，只有信任池中的成员才能将新的节点加入到该信任池中，新的节点无法检测到信任池，必须从信任池中进行探测</p>
</li>
</ul>
<h4 id="4-5-5-卷挂载"><a href="#4-5-5-卷挂载" class="headerlink" title="4.5.5 卷挂载"></a>4.5.5 卷挂载</h4><ul>
<li><p>GlusterFS卷挂载有三种方式：</p>
<ul>
<li>GlusterNativeClient：server端仅需配置glusterfs即可无法多余配置即可挂载，支持高可用<ul>
<li><code>mount-t glusterfs nodeX:NEW-VOLNAME /mnt/XX</code></li>
</ul>
</li>
<li>NFSv3：需手动放开nfs，并重启volume之后server上自动启动nfs进程以便提供nfs挂载<ul>
<li><code>gluster volume set VOLNAME nfs.disable off</code></li>
<li><code>mount -t nfs nodeX:NEW-VOLNAME /mnt/XX</code></li>
</ul>
</li>
<li>SAMBA：服务器端卷nfs.disable开启状态下，客户端安装启动samba并开放防火墙限制后，服务器端需改volumeoption并重启volume及glusterdservice后即可使用</li>
</ul>
</li>
<li><p>SAMBA方式挂载卷，还需要在服务器端创建samba user，并设置挂载目录修改权限，在客户端需要安装samba-client , cifs-utils</p>
</li>
<li><p>服务器端：</p>
<ul>
<li>编辑&#x2F;etc&#x2F;glusterfs&#x2F;glusterd.vol 文件加入：option rpc-auth-allow-insecure on</li>
<li>gluster volume set VOLNAME server.allow-insecure on</li>
<li>gluster volume set VOLNAME storage.batch-fsync-delay-usec 0</li>
<li>gluster volume set VOLNAME stat-prefetch off</li>
<li>adduser –s &#x2F;sbin&#x2F;nologin smbuser</li>
<li>smbpasswd –a smbuser</li>
<li>mount –t glusterfs nodeX:VOLNAME &#x2F;mnt</li>
</ul>
</li>
<li><p>客户端</p>
<ul>
<li>yum install –y cifs-utils</li>
<li>yum install –y sambe-client*</li>
<li>验证samba共享目录smbclient –L nodeX –U%</li>
<li>使用smbuser进行挂载 mount –t cifs –o user&#x3D;smbuser,pass&#x3D;XXX&#x2F;&#x2F;nodeX&#x2F;VOLNAME &#x2F;mnt</li>
</ul>
</li>
</ul>
<h4 id="4-5-6-部署Gluster客户端"><a href="#4-5-6-部署Gluster客户端" class="headerlink" title="4.5.6 部署Gluster客户端"></a>4.5.6 部署Gluster客户端</h4><ul>
<li>安装客户端服务<ul>
<li><code>yum install -y glusterfs glusterfs-fuse</code></li>
</ul>
</li>
<li>客户端添加地址解析，添加到所有存储节点的解析</li>
<li>创建挂载点并进行挂载<ul>
<li><code>mount -t glusterfs nodeX:NEW-VOLNAME /mnt/XX</code></li>
</ul>
</li>
<li>开机自动挂载，编辑<code>/etc/fstab</code>文件<ul>
<li><code>nodeX:NEW-VOLNAME /mnt/XX glusterfs defauts,_netdev 0 0</code></li>
</ul>
</li>
<li>自动挂载格式：<code>HOSTNAME-OR-IPADDRESS:/VOLNAME MOUNTDIR glusterfs defaults,_netdev 0 0</code></li>
</ul>
<h3 id="4-6-GlusterFS卷管理"><a href="#4-6-GlusterFS卷管理" class="headerlink" title="4.6 GlusterFS卷管理"></a>4.6 GlusterFS卷管理</h3><h4 id="4-6-1-启用、停止、查看和再平衡"><a href="#4-6-1-启用、停止、查看和再平衡" class="headerlink" title="4.6.1 启用、停止、查看和再平衡"></a>4.6.1 启用、停止、查看和再平衡</h4><ul>
<li>启用卷<ul>
<li><code>gluster volume start VOLNAME</code></li>
</ul>
</li>
<li>停止卷<ul>
<li><code>gluster volume stop VOLNAME</code></li>
</ul>
</li>
<li>查看卷信息<ul>
<li>查看单独卷状态：gluster volume status VOLNAME</li>
<li>查看卷信息：gluster volume info</li>
</ul>
</li>
<li>再平衡卷<ul>
<li>gluster volume rebalance VOLNAME start</li>
<li>gluster volume rebalance VOLNAME status</li>
</ul>
</li>
</ul>
<h4 id="4-6-2-删除卷"><a href="#4-6-2-删除卷" class="headerlink" title="4.6.2 删除卷"></a>4.6.2 删除卷</h4><ul>
<li>先停止卷<ul>
<li><code>gluster volume stop VOLNAME</code></li>
</ul>
</li>
<li>再执行删除卷<ul>
<li><code>gluster volume delete VOLNAME</code></li>
</ul>
</li>
<li>删除卷之后，释放的brick无法直接使用，需要在对应brick目录中，删除“.glusterfs”开头的隐藏文件，再执行如下两条命令后，才可以继续使用：<ul>
<li><code>setfattr -x trusted.glusterfs.volume-id /BRICK</code></li>
<li><code>setfattr -x trusted.gfid /BRICK</code></li>
</ul>
</li>
<li><code>setfattr -x trusted.glusterfs.volume-id</code> 用于删除文件或目录的扩展属性，其中<code>trusted.glusterfs.volume-id</code>是 GlusterFS 文件系统中的一个扩展属性，用于标识文件所属的 GlusterFS 卷</li>
<li><code>setfattr -x trusted.gfid</code>用于删除文件或目录的GFID（Global File Identifier）属性。GFID是GlusterFS文件系统中用于唯一标识文件或目录的属性。使用该命令可以删除GFID属性，但不会删除文件或目录本身</li>
</ul>
<h4 id="4-6-3-扩容和缩容"><a href="#4-6-3-扩容和缩容" class="headerlink" title="4.6.3 扩容和缩容"></a>4.6.3 扩容和缩容</h4><ul>
<li><p>在线扩容与缩容</p>
<ul>
<li>在线扩容volume</li>
<li><code>gluster volume add-brick VOLNAME NEW-BRICK</code></li>
</ul>
</li>
<li><p>在线缩容</p>
<ul>
<li>删除brick：<code>gluster volume remove-brick VOLNAME BRICKNAME start</code></li>
<li>查看操作状态：<code>gluster volume remove-brick VOLNAME BRICKNAME status</code></li>
<li>状态completed后，提交缩容操作：<code>gluster volume remove-brick VOLNAME BRICKNAME commit</code></li>
</ul>
</li>
<li><p>glusterfs中卷新增brick后，需要重新平衡布局后才可以使用该brick</p>
<ul>
<li>gluster volume rebalance VOLNAME start</li>
<li>gluster volume rebalance VOLNAME status</li>
</ul>
</li>
<li><p>通常扩容后需要手动执行再平衡命令，防止出现旧节点负载过高而出现性能问题，影响数据可靠性和可用性。缩容时系统会自动触发再平衡，避免剔除的节点或者子卷中的数据不可用，从而导致数据丢失</p>
</li>
</ul>
<h4 id="4-6-3-替换损坏的brick"><a href="#4-6-3-替换损坏的brick" class="headerlink" title="4.6.3 替换损坏的brick"></a>4.6.3 替换损坏的brick</h4><ul>
<li>在服务器端查看故障brick进程PID，并结束该进程<ul>
<li><code>kill -15 PID</code></li>
</ul>
</li>
<li>客户端卸载包含故障brick的卷</li>
<li>客户端重新挂载卷到新的挂载点&lt;客户端挂载点&gt;</li>
<li>查询查询故障节点的备份节点目的扩展属性:<code>getfattr -d-m.-e hex BRICK</code></li>
<li>客户端新建目录并删除<ul>
<li>cd&lt;客户端挂载点&gt;</li>
<li>mkdir testDir</li>
<li>rm -rf test Dir</li>
</ul>
</li>
<li>设置扩展属性触发自愈<ul>
<li>&#96;setfattr -n trusted.non-existent-key -v abc &lt;客户端挂载点&gt;</li>
<li><code>setfattr -x trusted.non-existent-key &lt;客户端挂载点&gt;</code></li>
</ul>
</li>
<li>强制替换卷<ul>
<li><code>gluster volume replace-brick VOLNAME BAD-BRICK NEW-BRICK commit force</code></li>
</ul>
</li>
<li>扩展属性是现代文件系统普遍支持，而又不容易被用户发现的特性。Glusterfs中DHT，AFT，stripe都广泛使用了扩展属性即xattr。xattr是一个key-value结构， 包括一个字符串key, 和一个二进制的value</li>
<li>在glusterfs中 当set&#x2F;get xattr的时候，会触发gluster server的相关操作</li>
<li>每当添加&#x2F;删除一个brick的时候，要重新计算xattr中存放的哈希区间</li>
<li>比如一个叫test1的afr卷，由test1-client-0和test1-client-1两个brick组成。 那么test1-client-0上的文件就会具有名为 trusted.afr.test1-client-1的xattr。在一个brick上的操作会在其他所有brick上的xattr中记录</li>
</ul>
<h2 id="0x05-缩略语"><a href="#0x05-缩略语" class="headerlink" title="0x05 缩略语"></a>0x05 缩略语</h2><p><img src="/assets/03%20openEuler%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/file-20250519034104829.png"></p>
	
		</div>
		
		<div id="current-post-cover" data-scr="/img/cart_cover.jpg"></div>

		<!-- relate post, comment...-->
		<div class="investment-container">
			<div class="investment-header">
				<div class="investment-title-1">
					<div class="on">相关文章</div>
					<div>评论</div>
					<div>分享</div>
				</div>
				<div class="investment-title-2">	            
					
	<span>
		<a id="totop-post-page">返回顶部</a>
		
			<a href="/2025/05/19/openEuler/%E5%AE%9E%E9%AA%8C/IA/01%20openEuler%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/" title="" rel="prev">
				&laquo;上一篇
			</a>
		
		
			<a href="/2025/03/08/openEuler/%E7%AC%94%E8%AE%B0/IP/06%20openEuler%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/" title="06 openEuler操作系统安全加固" rel="next">
				下一篇&raquo;
			</a>
			
	</span>


      		
				</div>	
			</div>
			
			<div class="investment-content">
				<div class="investment-content-list">
					

<div class="relate-post">
	
		<ul>
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IA/09%20Samba%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/" title="09 Samba文件共享服务器管理">
								09 Samba文件共享服务器管理			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 19日, 2025				
							</p>
							<p class="relate-post-content">
								完成openEuler系统基础命令操作后，可以基于openEuler及软件搭建各类服务，应用到各个IT系统中，基于openEuler及Samba可以完成文件共享服务器的搭建。
学完本课程后，你将能够:

基于openEuler系统文件...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IA/09%20Samba%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/" title="09 Samba文件共享服务器管理">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="09 Samba文件共享服务器管理"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IA/08%20%E4%BD%BF%E7%94%A8shell%E8%84%9A%E6%9C%AC/" title="08 使用shell脚本">
								08 使用shell脚本			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 19日, 2025				
							</p>
							<p class="relate-post-content">
								
本课程基于 openEuler
介绍关于 Shell 的基础知识
结合实际案例展示 Shell 脚本编写的最佳实践

学完本课程后，您应该能：

熟悉 Shell 基础知识
掌握 Shell 编程基础
能够编写常用的 Shell 脚...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IA/08%20%E4%BD%BF%E7%94%A8shell%E8%84%9A%E6%9C%AC/" title="08 使用shell脚本">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="08 使用shell脚本"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IA/06%20%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%AD%98%E5%82%A8/" title="06 管理文件系统及存储">
								06 管理文件系统及存储			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 19日, 2025				
							</p>
							<p class="relate-post-content">
								本章主要讲述文件系统、磁盘存储、逻辑卷存储的基础概念以及如何管理、使用文件系统和存储，以及对一些常用操作命令的介绍。
学完本课程后，您将能够：

了解文件系统及存储的基本概念
掌握磁盘存储的挂载和使用方法
掌握逻辑卷的管理方法


0...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IA/06%20%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%AD%98%E5%82%A8/" title="06 管理文件系统及存储">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="06 管理文件系统及存储"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IA/05%20%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%B9%B6%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1/" title="05 安装软件并管理服务">
								05 安装软件并管理服务			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 19日, 2025				
							</p>
							<p class="relate-post-content">
								本章节主要讲述openEuler中安装软件包三种方式：rpm安装、源码安装以及yum安装的相关概念以及具体的操作命令，并且介绍了systemd管理服务的概念以及操作方式。
0x01 RPM管理软件包1.1 RPM软件包Linux软件包...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2025/05/19/openEuler/%E7%AC%94%E8%AE%B0/IA/05%20%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%B9%B6%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1/" title="05 安装软件并管理服务">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="05 安装软件并管理服务"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2025/03/08/openEuler/%E7%AC%94%E8%AE%B0/IP/06%20openEuler%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/" title="06 openEuler操作系统安全加固">
								06 openEuler操作系统安全加固			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								三月 8日, 2025				
							</p>
							<p class="relate-post-content">
								操作系统是互联网不可或缺的基础设施之一，也是生产、处理和存储价值数据的实体。同时openEuler作为Linux发行版系统，具有开源、免费的特点，拥有丰富健康的生态环境和社区支持。正因如此，保障其安全的重要性不言而喻。本章节以操作系统...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2025/03/08/openEuler/%E7%AC%94%E8%AE%B0/IP/06%20openEuler%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/" title="06 openEuler操作系统安全加固">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="06 openEuler操作系统安全加固"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2025/03/06/openEuler/%E7%AC%94%E8%AE%B0/IP/05%20shell%E8%84%9A%E6%9C%AC%E8%BF%9B%E9%98%B6/" title="05 shell脚本进阶">
								05 shell脚本进阶			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								三月 6日, 2025				
							</p>
							<p class="relate-post-content">
								前言本章主要讲述Shell脚本的进阶功能，包括条件判断、函数、正则表达式、grep、sed、awk命令。

掌握条件判断的使用
掌握函数的常见操作
掌握grep语法与常见操作
掌握正则表达式的基本用法
掌握sed语法与常见操作
掌握a...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2025/03/06/openEuler/%E7%AC%94%E8%AE%B0/IP/05%20shell%E8%84%9A%E6%9C%AC%E8%BF%9B%E9%98%B6/" title="05 shell脚本进阶">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="05 shell脚本进阶"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2025/03/04/openEuler/%E7%AC%94%E8%AE%B0/IP/02%20openEuler%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/" title="02 openEuler集群架构介绍">
								02 openEuler集群架构介绍			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								三月 4日, 2025				
							</p>
							<p class="relate-post-content">
								前言随着互联网的发展，单机应用已经无法满足用户的需求，因此集群应用而生本章将主要介绍高可用集群与负载均衡集群的实现工具的配置，包括LVS、HAProxy、Nginx和Keepalived 。目标

熟悉LVS的搭建和配置
熟悉Ngin...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2025/03/04/openEuler/%E7%AC%94%E8%AE%B0/IP/02%20openEuler%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/" title="02 openEuler集群架构介绍">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="02 openEuler集群架构介绍"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2025/03/04/openEuler/%E5%AE%9E%E9%AA%8C/IP/02%20openEuler%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/01%20LVS%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/" title="01 LVS配置实践">
								01 LVS配置实践			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								三月 4日, 2025				
							</p>
							<p class="relate-post-content">
								1.1 LVS&#x2F;NAT 模式配置1.1.1 实验介绍本实验将通过 LVS 负载均衡的方式访问一个 Nginx 集群。在实际工作场景中，集群向外提供服务时显示的内容是一致的，但在本实验中为了将 LVS 的算法体现的比较明显，N...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2025/03/04/openEuler/%E5%AE%9E%E9%AA%8C/IP/02%20openEuler%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/01%20LVS%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/" title="01 LVS配置实践">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="01 LVS配置实践"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2025/03/02/openEuler/%E5%AE%9E%E9%AA%8C/IP/01%20openEuler%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1/03%20DNS%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/" title="03 DNS相关配置">
								03 DNS相关配置			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								三月 2日, 2025				
							</p>
							<p class="relate-post-content">
								3.1 实验介绍3.1.1 关于本实验本实验基于《3.3.2 Nginx 负载均衡配置》进行，将使用 DNS 服务器代替原先的静态 DNS 为用户端提供对应服务。
3.2 安装 DNS 软件3.2.1 资源准备按照实验组网介绍和实验设...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2025/03/02/openEuler/%E5%AE%9E%E9%AA%8C/IP/01%20openEuler%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1/03%20DNS%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/" title="03 DNS相关配置">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="03 DNS相关配置"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2025/02/28/openEuler/%E5%AE%9E%E9%AA%8C/IA/08%20shell%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" title="08 shell脚本语言基础">
								08 shell脚本语言基础			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								二月 28日, 2025				
							</p>
							<p class="relate-post-content">
								8.1 实验介绍8.1.1 实验介绍在对系统进行运维时，shell 脚本给了我们很大帮助。通过 shell 脚本，可以大大减少工作量。本实验主要介绍 shell 脚本的概念及使用。
8.1.2 实验目标
掌握全局变量及局部变量；
掌握...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2025/02/28/openEuler/%E5%AE%9E%E9%AA%8C/IA/08%20shell%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" title="08 shell脚本语言基础">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/cart_cover.jpg" alt="08 shell脚本语言基础"/>
							</a>
						</div>
					</li>												
			
		</ul>
	
</div>	
				</div>
				<div class="investment-content-list">
					<div class="layout-comment">

	
		<div class="config-info">
			Please check the parameter of <b>comment</b> in config.yml of hexo-theme-Annie!
		</div>	
	

</div>
				</div>
				<div class="investment-content-list">
					<div class="layout-share">
	
	

		
			
			<!-- socialShare share -->
			<div class="social-share"></div>

<!--  css & js -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
<script async src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
			
		
		
	
</div>


				</div>
			</div>	
		</div>
	</div>
</div>

<!-- show math formula -->



	





<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">


<script src="/plugin/fancybox/jquery.fancybox.js"></script>


<script type="text/javascript">
	(function gallerySet(){
		let titleID = $('.article-title a'),
			imageID = $('.article-content img'),
			videoID = $('.article-content video');
		
		let postTitle = titleID.text() ? titleID.text() : "No post title!";
		
		imageID.each(function() {
			let imgPath = $(this).attr('src'),
				imgTitle = $(this).attr('alt') ? $(this).attr('alt') : "No image description!";
		
			//给每个匹配的<img>元素打包, 即添加父元素<a>
			$(this).wrap('<a data-fancybox="gallery" data-caption="《 ' + postTitle + ' 》' + imgTitle + '"href="' + imgPath + '"> </a>');
		});
		
		videoID.each(function() {
			let videoPath = $(this).attr('src');
		
			//给每个匹配的<img>元素打包, 即添加父元素<a>
			$(this).wrap('<a data-fancybox href=" ' + videoPath + ' "> </a>');
		});
		
		//TODO：支持html5 video

		if($('#layout-post').length) {
			$('[data-fancybox="gallery"]').fancybox({
				loop: true,
				buttons: [
					"zoom",
					"share",
					"slideShow",
					"fullScreen",
					//"download",
					"thumbs",
					"close"
				],
				protect: true
			});
		}
	})();
</script>
		</main>

		<!--footer-->
		<footer>
	<div id="navigation-show">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories" target="_blank">分类</a>
		</li>
		
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags" target="_blank">标签</a>
		</li>
		
	
		<li class="menu-about">
			<a href="/about" class="menu-item-about" target="_blank">关于</a>
		</li>
		
	
		<li class="menu-gallery">
			<a href="/gallery" class="menu-item-gallery" target="_blank">相册</a>
		</li>
		
	

	
</ul>
	</div>

	<div class="copyright">
		<p>
			 
				&copy;2017 - 2025, content by Sariay. All Rights Reserved.
			
			
				<a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> Theme <a href="https://github.com/Sariay/hexo-theme-Annie" title="Annie" target="_blank" rel="noopener">Annie</a> by Sariay.
			
		</p>
		<p>
			

	<!-- busuanzi -->
	<!-- busuanzi -->



			<a href="javascript:zh_tran('s');" class="zh_click" id="zh_click_s">简体</a> 
			<a href="javascript:zh_tran('t');" class="zh_click" id="zh_click_t">繁體</a>				
		</p>
	</div>		
</footer>
		
	<!-- Local or hitokoto! -->

	
<script src="/plugin/motto/motto.js"></script>

	
	<script type="text/javascript">
		(function motto(){
			let mottoText = getMingYanContent().split('</br> - </br>'),
			
			mottoTextContent = mottoText[0]?mottoText[0]:'请刷新...',
			
			mottoTextFrom = mottoText[1]?mottoText[1]:'one/一个';
			
			mottoTextContent = mottoTextContent.trim().substring(0, 100);
		
			$("#motto-content").html( mottoTextContent);
			$("#motto-author").html( mottoTextFrom  );
		})();	
	</script>	



<!-- love effect -->


<!-- back to top -->

	<div id="totop">
	<span class="icon-circle-up"></span>
</div>



<!-- site analysis -->


	<!-- site-analysis -->
	
	
	
	
	
 

<!-- leancloud -->


	<!-- leancloud -->
	<!--
	时间：2018-11-27
	描述：
		文章访问量：visitors
		文章喜欢量：likes	
		文章排行榜：topNPost
		其他得说明：
			01-Cookie相关的函数 
				https://blog.csdn.net/somehow1002/article/details/78511541（Author：somehow1002）
			02-visitors相关的函数 
				https://blog.csdn.net/u013553529/article/details/63357382（Author：爱博客大伯）
				https://notes.doublemine.me/2015-10-21-为NexT主题添加文章阅读量统计功能.html（Author：夏末）
			03-topNPost相关的函数
				https://hoxis.github.io/hexo-next-read-rank.html（Author：hoxis）
			04-likes相关的函数，
				参考了01 & 02进行简单的设计与实现
-->


	

  



<script src="/plugin/chinese/chinese.js"></script>
<script src="/plugin/imagelazyloader/yall.min.js"></script>
<script src="/plugin/imageloaded/imagesloaded.pkgd.min.js"></script>
<script src="/plugin/nicescroll/jquery.nicescroll.js"></script>
<script src="/plugin/resizediv/resizediv.js"></script>
<script src="/js/main.js"></script>

	</body>	
</html>